<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AVRTools: Advanced Features</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AVRTools
   </div>
   <div id="projectbrief">A Library for the AVR ATmega328 and ATmega2560 Microcontrollers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Advanced Features </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The AVRTools library includes either more advanced features:</p>
<ul>
<li><a class="el" href="AdvancedFeatures.html#AdvancedSerial">Advanced serial (USART) module</a></li>
<li><a class="el" href="AdvancedFeatures.html#AdvancedI2c">I2C modules</a></li>
<li><a class="el" href="AdvancedFeatures.html#AdvancedLcd">I2C-based LCD module</a></li>
<li><a class="el" href="AdvancedFeatures.html#InterruptUtils">Interrupt utilities module</a></li>
<li><a class="el" href="AdvancedFeatures.html#SPI">SPI module</a></li>
<li><a class="el" href="AdvancedFeatures.html#MemUtil">Memory utilities module</a></li>
<li><a class="el" href="AdvancedFeatures.html#SimDelay">Simple delays module</a></li>
<li><a class="el" href="AdvancedFeatures.html#AdvancedGpioVars">GPIO pin variables</a></li>
</ul>
<p>These features provide functionality that is different from that provided by the Arduino libraries, either in the design of their interface or in the underlying implementation, or both. While the core modules of the AVRTools library are basically independent and can be used individually, these advanced features depend in various ways upon the core modules and, sometimes, each other. These dependencies are highlighted in the corresponding sections.</p>
<h1><a class="anchor" id="AdvancedSerial"></a>
Advanced serial (USART) module</h1>
<p>The advanced USART module provides two different high-level interfaces to USART0 hardware available on the Arduino Uno (ATmega328) and the Arduino Mega (ATmega2560). These provide serial input and output that is flexible, buffered, and asynchronous by exploiting the interrupts that are associated with the USART0 hardware. This means the transmit functions return immediately after queuing data in the output buffer for transmission, and the actual transmission happens asynchronously while your code continues to execute. Similarly, data is received asynchronously and placed into the input buffer for your code to read at its convenience.</p>
<p>If you try to queue more data than the transmit buffer can hold, the write functions will block until there is room in the buffer (as a result of data being transmitted). The receive buffer, however, will overwrite if it gets full. You must clear the receive buffer by reading it regularly when receiving significant amounts of data. The sizes of the transmit and receive buffers can be set at compile time via macro constants.</p>
<p>Two interfaces are provided. The first is provided in namespace <a class="el" href="namespaceUSART0.html" title="This namespace bundles a high-level buffered interface to the USART0 hardware. It provides logical co...">USART0</a> and is a functional interface that makes use of the buffering and asynchronous transmit and receive capabilities of the microcontrollers. However, <a class="el" href="namespaceUSART0.html" title="This namespace bundles a high-level buffered interface to the USART0 hardware. It provides logical co...">USART0</a> is limited to transmitting and receiving byte and character streams. Think of <a class="el" href="namespaceUSART0.html" title="This namespace bundles a high-level buffered interface to the USART0 hardware. It provides logical co...">USART0</a> as a buffered version of the <a class="el" href="USART0Minimal_8h.html#ab8088594df45071a7b3ab6f9c9eba433" title="Receive a byte on USART0. ">receiveUSART0()</a> and <a class="el" href="USART0Minimal_8h.html#a4b3f1118bf21ff46625919343b0b9d9d" title="Transmit a single byte on USART0. ">transmitUSART0()</a> functions provided by the <a class="el" href="index.html#MinUsart">Minimal USART modules</a>.</p>
<p>The second interface is <a class="el" href="classSerial0.html" title="Provides a high-end interface to serial communications using USART0. ">Serial0</a>. <a class="el" href="classSerial0.html" title="Provides a high-end interface to serial communications using USART0. ">Serial0</a> is the most advanced and capable interface to the USART0 hardware. <a class="el" href="classSerial0.html" title="Provides a high-end interface to serial communications using USART0. ">Serial0</a> provides a object-oriented interface that includes the ability to read and write numbers of various types and in various formats, all asynchronously. <a class="el" href="classSerial0.html" title="Provides a high-end interface to serial communications using USART0. ">Serial0</a> is implemented using <a class="el" href="namespaceUSART0.html" title="This namespace bundles a high-level buffered interface to the USART0 hardware. It provides logical co...">USART0</a>, so you may mix the use of <a class="el" href="namespaceUSART0.html" title="This namespace bundles a high-level buffered interface to the USART0 hardware. It provides logical co...">USART0</a> and <a class="el" href="classSerial0.html" title="Provides a high-end interface to serial communications using USART0. ">Serial0</a> interfaces in your code (although it is not recommended).</p>
<p>To use these the advanced serial capabilities, include the file <a class="el" href="USART0_8h.html" title="This file provides functions that offer high-level interfaces to USART0 hardware, which is available ...">USART0.h</a> in your source code and link against the file USART0.cpp.</p>
<dl class="section note"><dt>Note</dt><dd>The advanced serial module is incompatible with the minimal interface to USART0. If you link against the file USART0.cpp (even if you don't actually use <a class="el" href="classSerial0.html" title="Provides a high-end interface to serial communications using USART0. ">Serial0</a> or <a class="el" href="namespaceUSART0.html" title="This namespace bundles a high-level buffered interface to the USART0 hardware. It provides logical co...">USART0</a>), do <em>not</em> call <a class="el" href="USART0Minimal_8h.html#a0007c3d50eaf3a8c1b92d2ea0b681fb1" title="Initialize USART0 for serial receive and transmit. ">initUSART0()</a> or <a class="el" href="USART0Minimal_8h.html#a3e99fdd93a3ace96152127ac994d419d" title="Release USART0, making pins 0 and 1 again available for non-USART use. ">releaseUSART0()</a>; there is no point in any case because the <a class="el" href="USART0Minimal_8h.html#ab8088594df45071a7b3ab6f9c9eba433" title="Receive a byte on USART0. ">receiveUSART0()</a> and <a class="el" href="USART0Minimal_8h.html#a4b3f1118bf21ff46625919343b0b9d9d" title="Transmit a single byte on USART0. ">transmitUSART0()</a> functions won't work. You may, however, use the minimal interface to access <a class="el" href="namespaceUSART1.html" title="This namespace bundles a high-level buffered interface to the USART1 hardware. It provides logical co...">USART1</a>, <a class="el" href="namespaceUSART2.html" title="This namespace bundles a high-level buffered interface to the USART2 hardware. It provides logical co...">USART2</a>, and/or <a class="el" href="namespaceUSART3.html" title="This namespace bundles a high-level buffered interface to the USART3 hardware. It provides logical co...">USART3</a> while simultaneously using <a class="el" href="classSerial0.html" title="Provides a high-end interface to serial communications using USART0. ">Serial0</a> and <a class="el" href="namespaceUSART0.html" title="This namespace bundles a high-level buffered interface to the USART0 hardware. It provides logical co...">USART0</a> to access USART0.</dd></dl>
<p>Use of the timeout feature in <a class="el" href="classSerial0.html" title="Provides a high-end interface to serial communications using USART0. ">Serial0</a> or <a class="el" href="namespaceUSART0.html" title="This namespace bundles a high-level buffered interface to the USART0 hardware. It provides logical co...">USART0</a> requires linking against SystemClock.cpp and calling <a class="el" href="SystemClock_8h.html#a81308abf4a2f57e7b17ce1c8e90d4a51" title="This function initializes a system clock that tracks elapsed milliseconds. ">initSystemClock()</a> from your start-up code.</p>
<p>If you are coding for the ATmega2560, you can also use <a class="el" href="namespaceUSART1.html" title="This namespace bundles a high-level buffered interface to the USART1 hardware. It provides logical co...">USART1</a>, <a class="el" href="namespaceUSART2.html" title="This namespace bundles a high-level buffered interface to the USART2 hardware. It provides logical co...">USART2</a>, and <a class="el" href="namespaceUSART3.html" title="This namespace bundles a high-level buffered interface to the USART3 hardware. It provides logical co...">USART3</a> and/or <a class="el" href="classSerial1.html" title="Provides a high-end interface to serial communications using USART1. ">Serial1</a>, <a class="el" href="classSerial2.html" title="Provides a high-end interface to serial communications using USART2. ">Serial2</a>, and <a class="el" href="classSerial3.html" title="Provides a high-end interface to serial communications using USART3. ">Serial3</a> to access the USART1, USART2, and USART3 hardware available on the ATmega2560. These work just like <a class="el" href="namespaceUSART0.html" title="This namespace bundles a high-level buffered interface to the USART0 hardware. It provides logical co...">USART0</a> and <a class="el" href="classSerial0.html" title="Provides a high-end interface to serial communications using USART0. ">Serial0</a>. Again, if you link against USART1.cpp, USART2.cpp, or USART3.cpp then you cannot use the corresponding minimal interfaces for USART1, USART2, and USART3, and calling <a class="el" href="USART1Minimal_8h.html#a8c42a3fdf1308b8e8bee2e44beba1729" title="Initialize USART1 for serial receive and transmit. ">initUSART1()</a> or <a class="el" href="USART1Minimal_8h.html#a6ea899853b102102aeffc78e2bd653af" title="Release USART1, making pins 0 and 1 again available for non-USART use. ">releaseUSART1()</a> (or their corresponding equivalents for the other USARTs) will put that USART in an inoperable configuration.</p>
<h1><a class="anchor" id="AdvancedI2c"></a>
I2C modules</h1>
<p>These two modules provide two different interfaces to the two-wire serial interface (TWI) hardware of the Arduino Uno (ATmega328) and Arduino Mega (ATmega2560), providing a high-level interface to I2C protocol communications. There are two different modules corresponding to whether your application will function as a <a class="el" href="AdvancedFeatures.html#AdvI2cMaster">Master</a> (as per the I2C protocol), or as a <a class="el" href="AdvancedFeatures.html#AdvI2cSlave">Slave</a>.</p>
<dl class="section note"><dt>Note</dt><dd>AVRTools does not support applications that function both as I2C Masters and I2C Slaves. The two I2C modules provided by AVRTools are incompatible and cannot be mixed.</dd></dl>
<p>Both modules offer interfaces that are buffered for both input and output which operate using interrupts associated with the TWI hardware. This means the asynchronous transmit functions return immediately after queuing data in the output buffer for transmission and the transmission happens asynchronously, using dedicated TWI hardware. Similarly, data is received asynchronously and placed into the input buffer.</p>
<h2><a class="anchor" id="AdvI2cMaster"></a>
I2C Master module</h2>
<p>The <a class="el" href="namespaceI2cMaster.html">I2C Master module</a> provides I2C-protocol-based interface to the TWI hardware that implements the Master portions of the I2C protocol. The interfaces are buffered for both input and output and operate using interrupts associated with the TWI hardware. This means the asynchronous transmit functions return immediately after queuing data in the output buffer for transmission and the transmission happens asynchronously, using dedicated TWI hardware. Similarly, data is received asynchronously and placed into the input buffer.</p>
<p>The interface offered by the <a class="el" href="namespaceI2cMaster.html">I2C Master module</a> is designed around the normal operating modes of the I2C protocol. From a Master device point of view, I2C communications consist of sending a designated device a message to do something, and then either:</p>
<ul>
<li>doing nothing because no further action required on the Master's part (e.g., telling the designated device to shutdown)</li>
<li>transmitting additional data needed by the designated device (e.g., you told the designated device to store some data, next you need to send the data)</li>
<li>receiving data from the designated device (e.g., telling the designated device to report the current temperature or to read back some data from its memory)</li>
</ul>
<p>For very simple devices, the receipt of the message itself can suffice to tell it to do something. More commonly, the instruction to the designated device consists of a single byte that passes a "register address" on the device. It is called a register address because it often corresponds directly to a memory register on the device. But it is best to think of it as an instruction code to the designated device (e.g., 0x01 = report the temperature; 0x02 = set the units to either degrees F or degrees C (depending on additional data sent by the Master); 0x03 = report the humidity; etc.)</p>
<p>The interface offered by the <a class="el" href="namespaceI2cMaster.html">I2C Master module</a> conforms directly to the above I2C paradigm. For convenience, the interface functions come in both synchronous and asynchronous versions. The synchronous versions simply call the asynchronous versions and block internally until the asynchronous operations are complete.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="namespaceI2cMaster.html">I2C Master module</a> is incompatible with the <a class="el" href="namespaceI2cSlave.html">I2C Slave module</a>: you must use and link against only one of the two modules.</dd></dl>
<h2><a class="anchor" id="AdvI2cSlave"></a>
I2C Slave module</h2>
<p>The <a class="el" href="namespaceI2cSlave.html">I2C Slave module</a> provides I2C-protocol-based interface to the TWI hardware that implements the Slave portions of the I2C protocol. The interfaces are buffered for both input and output and operate using interrupts associated with the TWI hardware. This means the functions return immediately after queuing data for transmission and the transmission happens asynchronously, using the dedicated TWI hardware. Similarly, data is received asynchronously and placed into a buffer.</p>
<p>The interface offered by the <a class="el" href="namespaceI2cSlave.html">I2C Slave module</a> is designed designed around the normal operating modes of the I2C protocol. From a Slave device point of view, I2C communications consist of receiving a message from the Master telling it to do something, and in response:</p>
<ul>
<li>Processing the message and taking whatever action is appropriate.</li>
<li>If that action includes returning data to the Master, queuing the data for transmission.</li>
</ul>
<p>The interface offered by the <a class="el" href="namespaceI2cSlave.html">I2C Slave module</a> conforms directly to the above I2C paradigm.</p>
<h1><a class="anchor" id="AdvancedLcd"></a>
I2C-based LCD module</h1>
<p>The <a class="el" href="classI2cLcd.html">I2C-based LCD module</a> provides a high-level interface to an LCD offering an I2C interface. The most common variant of this is HD44780U controlled LCD driven by an MCP23017 that offers an I2C interface (such LCDs are available from Adafruit and SparkFun). This module allows you to write to the LCD much as it if were a serial device and includes the ability to write numbers of various types in various formats. It also lets you detect button presses on the 5-button keypad generally assocaited with such devices.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classI2cLcd.html">I2C-based LCD module</a> requires the <a class="el" href="namespaceI2cMaster.html">I2C Master module</a>.</dd></dl>
<h1><a class="anchor" id="InterruptUtils"></a>
Interrupt utilities module</h1>
<p>It is often necessary to suppress interrupts to avoid conflicts between the main thread of code execution and code that runs in interrupts. While it is easy to suppress all interrupts using the <code>avr-gcc</code> built-in <code>cli()</code> function, often a more selective approach is desireable. And when interrupts are suppressed, it is also easy to forget to re-enable them.</p>
<p>The <a class="el" href="namespaceInterrupts.html" title="This namespace bundles various utility classes designed to suppress selected interrupts using the RAI...">Interrupts</a> module addresses these problems by providing simple utility C++ classes whose constructors disable certain kinds of interrupts and corresponding destructors re-enable them. A block of code can suppress interrupts by simply declaring an object of one of these classes; interrupts will be automatically restored when the block of code is exited for any reason. For example, if you want to suppress two of the pin change interrupts in a certain block of code, you would do this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="InterruptUtils_8h.html">AVRTools/InterruptUtils.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// ... snip ...</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> dontLetPinChangeInterruptsHappenHere( uint8_t data )</div><div class="line">{</div><div class="line">    <span class="comment">// Pin change interrupts 1 and 2 conflict with this function, so suppress these</span></div><div class="line">    <span class="comment">// two pin change interrupts for the duration of this function</span></div><div class="line">    <a class="code" href="classInterrupts_1_1PinChangeOff.html">Interrupts::PinChangeOff</a> interruptsOff( <a class="code" href="namespaceInterrupts.html#a2608f855da48bb9522bb33a1cf3f4e43a79c561a090ca7acf5cb51564a0909bea">kPinChangeInterrupt1</a> | <a class="code" href="namespaceInterrupts.html#a2608f855da48bb9522bb33a1cf3f4e43aa0e51759adf2aef128dd672e74ac7427">kPinChangeInterrupt2</a> );</div><div class="line"></div><div class="line">    <span class="comment">// Here is some code that would conflict with the interrupt routines</span></div><div class="line">    <span class="comment">// assigned to pin change interrupt 1 and 2...</span></div><div class="line">    <span class="comment">// ... snip ...</span></div><div class="line"></div><div class="line">    <span class="comment">// Pin change interrupts 1 and 2 are automatically restored when this</span></div><div class="line">    <span class="comment">// function exits</span></div><div class="line">}</div></div><!-- fragment --><p>One common application for this is when using SPI transmissions in both main thread code and interrupt routines. See the documentation for the <a class="el" href="AdvancedFeatures.html#SPI">SPI module</a> for an example.</p>
<h1><a class="anchor" id="SPI"></a>
SPI module</h1>
<p>The <a class="el" href="namespaceSPI.html" title="This namespace bundles an interface to the SPI hardware subsystem on the AVR ATMega328p (Arduino Uno)...">SPI</a> module provides a high-level interface to the SPI hardware subsystem present on the AVR ATMega328p (Arduino Uno) and ATMega2560 (Arduino Mega) microcontrollers. This module provides functions to initialize the SPI hardware, configure it appropriately for your needs, and transmit (and receive) data. While the SPI hardware supports asynchronous transmission via an interrupt functions (analogous to the I2C hardware), AVRTools does not implement asynchronous SPI transmission, instead implementing sychronous transmission that polls the appropriate SPI status register to determine when transmission of a byte has completed. The reason for this is that testing of polling and interrupt implementations by <a href="https://www.tablix.org/~avian/blog/archives/2012/06/spi_interrupts_versus_polling/">Tomaž Šolc</a> has shown that polling implementations are faster than interrupt-based implementations by nearly a factor of 2. This is because SPI can work at half the CPU frequency; at this speed, the CPU can only execute about 16 instructions per byte sent via SPI. When the CPU is calling interrupts so often, the overhead of calling the interrupt function dominates, and is greater than the overhead of a simple polling loop.</p>
<p>The <a class="el" href="namespaceSPI.html" title="This namespace bundles an interface to the SPI hardware subsystem on the AVR ATMega328p (Arduino Uno)...">SPI</a> module only implements SPI operation in master mode. Slave mode SPI operation is not supported at this time. In master mode, you may use any free pin as the Slave Select (SS) for the remote device.</p>
<p>The <a class="el" href="namespaceSPI.html" title="This namespace bundles an interface to the SPI hardware subsystem on the AVR ATMega328p (Arduino Uno)...">SPI</a> module contains functions to enable and disable the <a class="el" href="namespaceSPI.html" title="This namespace bundles an interface to the SPI hardware subsystem on the AVR ATMega328p (Arduino Uno)...">SPI</a> hardware. Note that when enabled the SPI hardware takes control of the MOSI, MISO, and CLK pins. It also sets the local SS pin to output mode to prevent inadvertent automatic triggering of slave-mode by the SPI hardware. This happens if a low signal is received on the SS pin. The SS pin can still be used as a general purpose output port, because it doesn't affect SPI operations as long as it remains in output mode.</p>
<p>To use the <a class="el" href="namespaceSPI.html" title="This namespace bundles an interface to the SPI hardware subsystem on the AVR ATMega328p (Arduino Uno)...">SPI</a> module, call the <a class="el" href="namespaceSPI.html#a64fcb132bfec5b4d6e5d190064d83d90" title="Enable the SPI subsystem for transmission. ">SPI::enable()</a> function as part of your initialization. Then when you are aready to transmit, configure the hardware appropriately using <a class="el" href="namespaceSPI.html#aac2f8ee9dc17edbf7d7af7e0b3200a53" title="Set the configuration of SPI subsystem to match the needs of the system you are going to communicate ...">SPI::configure()</a>, write the receiving device's slave select pin LOW, call <a class="el" href="namespaceSPI.html#a9762564586a02baa41d3c0792c2ee33a" title="Transmit a single byte using the SPI subsystem. ">SPI::transmit()</a> (or any one of the related transmit functions) any number of times to transfer data, and finally write the receiving device's SS pin HIGH to indicate that transmission has ended.</p>
<p>One potential complication may occur if you use SPI to transmit data from inside an interrupt routine and also use SPI in the main execution thread. In this situation, you have to make sure that a SPI transmission in the main thread is not interrupted by a SPI transmission from an interrupt routine. You can do this very easily by disabling the appropriate interrupt (or interrupts) during the period of time that an SPI transmission occurs in the main thread. The classes in InterruptUtils allow you to selectively disable interrupts.</p>
<p>The following example code illustrates how to do this. Assume that SPI is used by interrupt routines associated with pin change interrupts 0 and 1, and with external interrupt 1. Your main thread code would then look like this:</p>
<div class="fragment"><div class="line"><span class="comment">// ... snip ...</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="SPI_8h.html">AVRTools/SPI.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="InterruptUtils_8h.html">AVRTools/InterruptUtils.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// ... snip ...</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> initializeEverything()</div><div class="line">{</div><div class="line">    <span class="comment">// ... snip ...</span></div><div class="line"></div><div class="line">    <span class="comment">// Initialize the SPI subsystem</span></div><div class="line">    <a class="code" href="namespaceSPI.html#a64fcb132bfec5b4d6e5d190064d83d90">SPI::enable</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ... snip ...</span></div><div class="line"></div><div class="line">uint8_t sendData( uint8_t data )</div><div class="line">{</div><div class="line">  <span class="comment">// SPI is used by the interrupt functions that respond to pin change interrupts 0 and 1,</span></div><div class="line">  <span class="comment">// and external interrupt 1.  To prevent clashes, we suppress these three interrupts</span></div><div class="line">  <span class="comment">// for the duration of this function</span></div><div class="line">  <a class="code" href="classInterrupts_1_1PinChangeOff.html">Interrupts::PinChangeOff</a> pinChangeOff( <a class="code" href="namespaceInterrupts.html#a2608f855da48bb9522bb33a1cf3f4e43a9e40a6b26ee8ebddcee5ff88f19e4c53">kPinChangeInterrupt0</a> | <a class="code" href="namespaceInterrupts.html#a2608f855da48bb9522bb33a1cf3f4e43a79c561a090ca7acf5cb51564a0909bea">kPinChangeInterrupt1</a> );</div><div class="line">  <a class="code" href="classInterrupts_1_1ExternalOff.html">Interrupts::ExternalOff</a> externalOff( <a class="code" href="namespaceInterrupts.html#a5e27a0834f4764f0094317f9fa711f5aa334fa384d3190038494ecd3c1f0aa4f5">kExternalInterrupt1</a> );</div><div class="line"></div><div class="line">  <span class="comment">// Configure SPI</span></div><div class="line">  <a class="code" href="namespaceSPI.html#aac2f8ee9dc17edbf7d7af7e0b3200a53">SPI::configure</a>( SPISettings( 4000000, <a class="code" href="namespaceSPI.html#a6b319b8392a89d8ce1121ef2f22bf38ca3cb5aeb22df6f6aed3d5c2b9660ddcdb">SPI::kLsbFirst</a>, <a class="code" href="namespaceSPI.html#a405f07c121d93d86385497db869ef073aff9467324663c0726e94c6283e74a1c5">SPI::kSpiMode2</a> ) );</div><div class="line"></div><div class="line">  <span class="comment">// Set the remote slave SS pin low to initiate a transmission</span></div><div class="line">  <a class="code" href="GpioPinMacros_8h.html#afb3e478c66e48ce826a6727737525bb9">setGpioPinLow</a>( pConnectedToSlaveSS );</div><div class="line"></div><div class="line">  <span class="comment">// Transmit (and receive)</span></div><div class="line">  uint8_t retVal = <a class="code" href="namespaceSPI.html#a9762564586a02baa41d3c0792c2ee33a">SPI::transmit</a>( data );</div><div class="line"></div><div class="line">  <span class="comment">// Set the remote slave SS pin high to terminate the transmission</span></div><div class="line">  <a class="code" href="GpioPinMacros_8h.html#afcd7e66a9c60b13bf749e18304a71ac6">setGpioPinHigh</a>( pConnectedToSlaveSSpin );</div><div class="line"></div><div class="line">  <span class="comment">// Interrupts automatically reset when this function exits</span></div><div class="line">  <span class="keywordflow">return</span> retVal;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="MemUtil"></a>
Memory utilities module</h1>
<p>The <a class="el" href="namespaceMemUtils.html">Memory Utilities module</a> provides functions that report the available memory in SRAM. These help you gauge in real-time whether your application is approaching memory exhaustion or the heap and stack are close to colliding. The primary function is <code><a class="el" href="namespaceMemUtils.html#a20a6955ad3756abee955d6b77970060b" title="Get the total free memory remaining in SRAM. ">freeSRAM()</a></code> which returns the number of free bytes remaining in SRAM.</p>
<h1><a class="anchor" id="SimDelay"></a>
Simple delays module</h1>
<p>The <a class="el" href="SimpleDelays_8h.html">Simple Delays module</a> provides simple delay functions that do not involve timers or interrupts. These functions simply execute a series of nested loops with known and precise timing.</p>
<p>These functions are all implemented directly in assembler to guarantee cycle counts. However, if interrupts are enabled, then the delays will be at least as long as requested, but may actually be longer. These delay functions are:</p>
<ul>
<li><a class="el" href="SimpleDelays_8h.html#a28e4e83c687b9e9cbe7dc0d8a2d4459b" title="Delay a given number of quarter microseconds. Due to function call overhead, at 16 MHz the smallest p...">delayQuartersOfMicroSeconds( uint16_t nbrOfQuartersOfMicroSeconds )</a>;</li>
<li><a class="el" href="SimpleDelays_8h.html#a11c15b958da6b2377e7c0b7597e39724" title="Delay a given number of milliseconds. Despite function call overhead, this function is accurate withi...">delayWholeMilliSeconds( uint8_t nbrOfMilliSeconds )</a>;</li>
<li><a class="el" href="SimpleDelays_8h.html#a796be98fbdc09e016755b61c4fcadcd0" title="Delay a given number of tenths of a seconds. Despite function call overhead, this function is accurat...">delayTenthsOfSeconds( uint8_t nbrOfTenthsOfSeconds )</a>;</li>
</ul>
<h1><a class="anchor" id="AdvancedGpioVars"></a>
GPIO pin variables</h1>
<p>There is sometimes a desire to assign GPIO pins to variables. Unfortunately, the pin name macros defined for you when you include <a class="el" href="ArduinoPins_8h.html" title="This file is the primary one that users should include to access and use the pin name macros...">ArduinoPins.h</a> or that you define yourself using <a class="el" href="GpioPinMacros_8h.html#a26d39acd45b82361f0baf73e505eb315" title="Primary macro-function for defining a GPIO pin name. ">GpioPin()</a>, <a class="el" href="GpioPinMacros_8h.html#aa6d03fd07a19736f078173b08f1bd0c5" title="Secondary macro-function for defining a GPIO pin name for GPIO pins that support analog conversion...">GpioPinAnalog()</a>, or <a class="el" href="GpioPinMacros_8h.html#a9781f1f00f208be7fe33c5cf481a273a" title="Secondary macro-function for defining a GPIO pin name for GPIO pins that support PWM output...">GpioPinPwm()</a> cannot be assigned to variables or used for anything other than passing them to the specialized macro functions designed to handle them. This is normally not a big limitation: the use of GPIO pins is generally encapsulated in functions or classes that function much like software drivers for hardware, hiding the pins from the rest of the application. Treating the pins as macro constants usually works well in such situations. However, there do sometimes arise situations in which it would be convenient to be able to assign GPIO pins to variables and manipulate GPIO pins via those variables.</p>
<p>AVRTools provides a way to convert GPIO pins macros into variables and provides corresponding functions for manipulating those variables. However, this convenience comes at a very significant cost for two reasons.</p>
<p>The first reason is that functions that manipulate AVR I/O registers via variables are inherently slower than those that manipulate them as constants. When using the GPIO pin macros, most operations map directly to <code>in</code> and <code>out</code> AVR assembler instructions. However, due to the constraints on these instructions, when using variables to pass the pins, the compiler must use slower <code>ld</code> and <code>st</code> instruction to access the I/O registers (for more on this issue, see the section in the <a href="http://www.nongnu.org/avr-libc/user-manual/FAQ.html#faq_port_pass">AVR-GCC FAQ</a>). In addition, when using variables and function calls the bit-shifts needed to generate suitable masks have to be generated at run-time (often using loops) instead of at compile-time.</p>
<p>The second reason is that the variables that store GPIO pins are rather large. On the AVR hardware architecture, manipulating a GPIO pin requires knowing three different I/O registers (DDRn, PORTn, and PINn) and a bit number. Access an analog pin requires a corresponding analog-to-digital channel number. Manipulating a PWM pin requires knowing two additional registers (OCRn[A/B] and TCCRnA) and another bit number (COMn[A/B]1). So a general-purpose variable representing a GPIO pin has to store all of these registers, bit numbers, and channel numbers. It is possible to create smaller GPIO pin variables by encoding information and using look-up tables. The costs are still there, and it is simply a choice of where to pay them. In AVRTools, the choice is to implement "heavy" variables and avoid look-up tables and encoding schemes.</p>
<p>In AVRTools, GPIO pin variables have type <a class="el" href="classGpioPinVariable.html" title="This class defines a type that can encode a GPIO pin as a variable. Read the section on GPIO Pin Vari...">GpioPinVariable</a>, which is a class defined in <a class="el" href="GpioPinMacros_8h.html" title="This file contains the primary macros for naming and manipulating GPIO pin names. ...">GpioPinMacros.h</a> (recall that this file is automatically included by <a class="el" href="ArduinoPins_8h.html" title="This file is the primary one that users should include to access and use the pin name macros...">ArduinoPins.h</a>). There are also three macros that you can use to initialize GPIO pin variables of type <a class="el" href="classGpioPinVariable.html" title="This class defines a type that can encode a GPIO pin as a variable. Read the section on GPIO Pin Vari...">GpioPinVariable</a>. The three are: <a class="el" href="GpioPinMacros_8h.html#a30dcbc33f1d98d34c345de2751c2715a" title="Create a GPIO pin variable of type GpioPinVariable from a GPIO pin macro. ">makeGpioVarFromGpioPin()</a>, <a class="el" href="GpioPinMacros_8h.html#aabd19255821d047efb7bde2c99b77c55" title="Create a GPIO pin variable of type GpioPinVariable that can be used for analog-to-digital reading fro...">makeGpioVarFromGpioPinAnalog()</a>, and <a class="el" href="GpioPinMacros_8h.html#a8bbad7120f8b139e8fc5819ad7e0771d" title="Create a GPIO pin variable of type GpioPinVariable that can be used for PWM from a GPIO pin macro...">makeGpioVarFromGpioPinPwm()</a>. These are used like this:</p>
<div class="fragment"><div class="line"><a class="code" href="classGpioPinVariable.html">GpioPinVariable</a>  pinA( <a class="code" href="GpioPinMacros_8h.html#a30dcbc33f1d98d34c345de2751c2715a">makeGpioVarFromGpioPin</a>( pPin10 ) );</div><div class="line"><a class="code" href="classGpioPinVariable.html">GpioPinVariable</a>  pinB = <a class="code" href="GpioPinMacros_8h.html#aabd19255821d047efb7bde2c99b77c55">makeGpioVarFromGpioPinAnalog</a>( pPinA01 );</div><div class="line"><a class="code" href="classGpioPinVariable.html">GpioPinVariable</a>  pinC( <a class="code" href="GpioPinMacros_8h.html#a8bbad7120f8b139e8fc5819ad7e0771d">makeGpioVarFromGpioPinPwm</a>( pPin03 ) );</div><div class="line"></div><div class="line"><a class="code" href="classGpioPinVariable.html">GpioPinVariable</a> pinArray[3];</div><div class="line">pinArray[0] = pinA;</div><div class="line">pinArray[1] = pinB;</div><div class="line">pinArray[2] = <a class="code" href="GpioPinMacros_8h.html#a30dcbc33f1d98d34c345de2751c2715a">makeGpioVarFromGpioPin</a>( pPin07 );</div></div><!-- fragment --><p>Which macro you choose depends upon what functionality of the GPIO pin you plan to access: you are free to use <a class="el" href="GpioPinMacros_8h.html#a30dcbc33f1d98d34c345de2751c2715a" title="Create a GPIO pin variable of type GpioPinVariable from a GPIO pin macro. ">makeGpioVarFromGpioPin()</a> with an analog pin macro (e.g., pPinA01) if you only plan to use the resulting variable digitally. But if you plan to use the analog capabilities of the GPIO pin, you must use <a class="el" href="GpioPinMacros_8h.html#aabd19255821d047efb7bde2c99b77c55" title="Create a GPIO pin variable of type GpioPinVariable that can be used for analog-to-digital reading fro...">makeGpioVarFromGpioPinAnalog()</a> to initialize the variable. Similarly for PWM functionality.</p>
<p>Once you've created GPIO pin variables using the above macros, these variables can be assigned and passed to functions as needed. To use these GPIO pin variables, there are special function analogs of the pin manipulation macros. These have the same names as the pin manipulation macros, except with a "V" appended:</p>
<table class="doxtable">
<tr>
<th align="left">Macro Version </th><th align="left">Function Version </th><th align="left">Purpose  </th></tr>
<tr>
<td align="left"><a class="el" href="GpioPinMacros_8h.html#a9b8f9345e37f8122fc8d71fdcb9147b5" title="Test if the mode of the GPIO pin is output (i.e., the corresponding DDRn bit is set). ">isGpioPinModeOutput( pinMacro )</a> </td><td align="left"><a class="el" href="GpioPinMacros_8h.html#ae3a770f4ebdd34827d99102721cb10ba" title="Test if the mode of the GPIO pin is output (i.e., the corresponding DDRn bit is set). ">isGpioPinModeOutputV( const GpioPinVariable&amp; pinVar )</a> </td><td align="left">Is the corresponding DDRn bit set? </td></tr>
<tr>
<td align="left"><a class="el" href="GpioPinMacros_8h.html#a80d626fa0cfee642acf7bbc78db91c7b" title="Test if the mode of the GPIO pin is input (i.e., the corresponding DDRn is clear). ">isGpioPinModeInput( pinMacro )</a> </td><td align="left"><a class="el" href="GpioPinMacros_8h.html#a747468ba121dd137c9115c67f72ecd9e" title="Test if the mode of the GPIO pin is input (i.e., the corresponding DDRn is clear). ">isGpioPinModeInputV( const GpioPinVariable&amp; pinVar )</a> </td><td align="left">Is the corresponding DDRn bit clear? </td></tr>
<tr>
<td align="left"><a class="el" href="GpioPinMacros_8h.html#a8802f2fa85c2db869518a49ca6313d84" title="Set the mode of the GPIO pin to output (i.e., set the corresponding DDRn bit). ">setGpioPinModeOutput( pinMacro )</a> </td><td align="left"><a class="el" href="GpioPinMacros_8h.html#a35f1608c15e9ca9aec4a373f65316f94" title="Set the mode of the GPIO pin to output (i.e., set the corresponding DDRn bit). ">setGpioPinModeOutputV( const GpioPinVariable&amp; pinVar )</a> </td><td align="left">Enable the corresponding DDRn bit </td></tr>
<tr>
<td align="left"><a class="el" href="GpioPinMacros_8h.html#a9e2956fa31869c862cc8ab76f8eec439" title="Set the mode of the GPIO pin to input (i.e., clear the corresponding DDRn and PORTn bits)...">setGpioPinModeInput( pinMacro )</a> </td><td align="left"><a class="el" href="GpioPinMacros_8h.html#aea4a25366a65942dec482f4baabdb164" title="Set the mode of the GPIO pin to input (i.e., clear the corresponding DDRn and PORTn bits)...">setGpioPinModeInputV( const GpioPinVariable&amp; pinVar )</a> </td><td align="left">Clear the corresponding DDRn bit </td></tr>
<tr>
<td align="left"><a class="el" href="GpioPinMacros_8h.html#a4bcd394397732af80f460f0a74d423fc" title="Set the mode of the GPIO pin to input with pullup (i.e., clear the corresponding DDRn bit and set the...">setGpioPinModeInputPullup( pinMacro )</a> </td><td align="left"><a class="el" href="GpioPinMacros_8h.html#acb65da8ef663115acb8f9ebf88d3663d" title="Set the mode of the GPIO pin to input with pullup (i.e., clear the corresponding DDRn bit and set the...">setGpioPinModeInputPullupV( const GpioPinVariable&amp; pinVar )</a> </td><td align="left">Clear the corresponding DDRn and PORTn bits </td></tr>
<tr>
<td align="left"><a class="el" href="GpioPinMacros_8h.html#a270fde2ca2cee11cee443221aadfaf3b" title="Read the value of the GPIO pin (i.e., return the value of correspoinding the PINn bit)...">readGpioPinDigital( pinMacro )</a> </td><td align="left"><a class="el" href="GpioPinMacros_8h.html#a9562677f5917b53739f5cc00b053e9e9" title="Read the value of the GPIO pin (i.e., return the value of correspoinding the PINn bit)...">readGpioPinDigitalV( const GpioPinVariable&amp; pinVar )</a> </td><td align="left">Return the value (0 or 1 ) of the corresponding PINn bit </td></tr>
<tr>
<td align="left"><a class="el" href="GpioPinMacros_8h.html#a18b0e937fe4dd68934585170a9141d4b" title="Write a value the GPIO pin (i.e., set or clear the correspoinding the PORTn bit). ...">writeGpioPinDigital( pinMacro, value )</a> </td><td align="left"><a class="el" href="GpioPinMacros_8h.html#ad94cd8c9e8efbabe144e33d1f36822bb" title="Write a value the GPIO pin (i.e., set or clear the correspoinding the PORTn bit). ...">writeGpioPinDigitalV( const GpioPinVariable&amp; pinVar, bool value )</a> </td><td align="left">Write a 0 or 1 to the corresponding PORTn bit </td></tr>
<tr>
<td align="left"><a class="el" href="GpioPinMacros_8h.html#afcd7e66a9c60b13bf749e18304a71ac6" title="Write a 1 to the GPIO pin (i.e., set the correspoinding the PORTn bit). ">setGpioPinHigh( pinMacro )</a> </td><td align="left"><a class="el" href="GpioPinMacros_8h.html#a6a841725322fd84357cefe881710ae57" title="Write a 1 to the GPIO pin (i.e., set the correspoinding the PORTn bit). ">setGpioPinHighV( const GpioPinVariable&amp; pinVar )</a> </td><td align="left">Set the corresponding PORTn bit </td></tr>
<tr>
<td align="left"><a class="el" href="GpioPinMacros_8h.html#afb3e478c66e48ce826a6727737525bb9" title="Write a 0 the GPIO pin (i.e., clear the correspoinding the PORTn bit). ">setGpioPinLow( pinMacro )</a> </td><td align="left"><a class="el" href="GpioPinMacros_8h.html#a5d844de3e52a8e4643e629b813d0f9ce" title="Write a 0 to the GPIO pin (i.e., clear the correspoinding the PORTn bit). ">setGpioPinLowV( const GpioPinVariable&amp; pinVar )</a> </td><td align="left">Clear the corresponding PORTn bit </td></tr>
<tr>
<td align="left"><a class="el" href="Analog2Digital_8h.html#a5043f69bc6307a1ada6ae3819ec11ff7" title="Read the analog value of the pin. ">readGpioPinAnalog( pinMacro )</a> </td><td align="left"><a class="el" href="Analog2Digital_8h.html#af524f355d7999c4b4f0d3f2285374676" title="Read the analog value of the pin. ">readGpioPinAnalogV( const GpioPinVariable&amp; pinVar )</a> </td><td align="left">Read an analog value from the corresponding ADC channel </td></tr>
<tr>
<td align="left"><a class="el" href="Pwm_8h.html#ad374c393f924ead532f5a0cd9e390d40" title="Write a PWM value to a pin. ">writeGpioPinPwm( pinMacro, value )</a> </td><td align="left"><a class="el" href="Pwm_8h.html#a24ff140fa1aca3e0c3ecbd3925719c3c" title="Write a PWM value to a pin. ">writeGpioPinPwmV( const GpioPinVariable&amp; pinVar, uint8_t value )</a> </td><td align="left">Set the corresonding PWM output level for that pin </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>GPIO pin variables can only be passed to the function versions; GPIO pin variables cannot be passed to the macro versions. Similarly, GPIO pin macros cannot be passed to the function versions.</dd></dl>
<p>To illustrate how GPIO pin variables can be used, here are two versions of a trivial program, the first using the macros, and the second using variables.</p>
<h2><a class="anchor" id="AdvancedGpioVarsExampleMacros"></a>
Example using GPIO pin macros</h2>
<p>Compiled for an Arduino Uno, the following program is 1,978 bytes.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ArduinoPins_8h.html">AVRTools/ArduinoPins.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="InitSystem_8h.html">AVRTools/InitSystem.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="SystemClock_8h.html">AVRTools/SystemClock.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define pRed            pPin10</span></div><div class="line"><span class="preprocessor">#define pYellow         pPin07</span></div><div class="line"><span class="preprocessor">#define pGreen          pPin04</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="InitSystem_8h.html#ae332dfb8661c411f6d461d4b068ebb81">initSystem</a>();</div><div class="line">    <a class="code" href="SystemClock_8h.html#a81308abf4a2f57e7b17ce1c8e90d4a51">initSystemClock</a>();</div><div class="line"></div><div class="line">    <a class="code" href="GpioPinMacros_8h.html#a8802f2fa85c2db869518a49ca6313d84">setGpioPinModeOutput</a>( pGreen );</div><div class="line">    <a class="code" href="GpioPinMacros_8h.html#a8802f2fa85c2db869518a49ca6313d84">setGpioPinModeOutput</a>( pYellow );</div><div class="line">    <a class="code" href="GpioPinMacros_8h.html#a8802f2fa85c2db869518a49ca6313d84">setGpioPinModeOutput</a>( pRed );</div><div class="line"></div><div class="line">    <a class="code" href="GpioPinMacros_8h.html#afcd7e66a9c60b13bf749e18304a71ac6">setGpioPinHigh</a>( pGreen );</div><div class="line">    <a class="code" href="GpioPinMacros_8h.html#afcd7e66a9c60b13bf749e18304a71ac6">setGpioPinHigh</a>( pYellow );</div><div class="line">    <a class="code" href="GpioPinMacros_8h.html#afcd7e66a9c60b13bf749e18304a71ac6">setGpioPinHigh</a>( pRed );</div><div class="line"></div><div class="line">    <a class="code" href="SystemClock_8h.html#a74d8aff40774c8a364845f0265776a24">delayMilliseconds</a>( 2000 );</div><div class="line"></div><div class="line">    <a class="code" href="GpioPinMacros_8h.html#afb3e478c66e48ce826a6727737525bb9">setGpioPinLow</a>( pGreen );</div><div class="line">    <a class="code" href="GpioPinMacros_8h.html#afb3e478c66e48ce826a6727737525bb9">setGpioPinLow</a>( pYellow );</div><div class="line">    <a class="code" href="GpioPinMacros_8h.html#afb3e478c66e48ce826a6727737525bb9">setGpioPinLow</a>( pRed );</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> ( 1 )</div><div class="line">    {</div><div class="line">        <a class="code" href="SystemClock_8h.html#a74d8aff40774c8a364845f0265776a24">delayMilliseconds</a>( 1000 );</div><div class="line"></div><div class="line">        <a class="code" href="GpioPinMacros_8h.html#afb3e478c66e48ce826a6727737525bb9">setGpioPinLow</a>( pRed );</div><div class="line">        <a class="code" href="GpioPinMacros_8h.html#afcd7e66a9c60b13bf749e18304a71ac6">setGpioPinHigh</a>( pGreen );</div><div class="line"></div><div class="line">        <a class="code" href="SystemClock_8h.html#a74d8aff40774c8a364845f0265776a24">delayMilliseconds</a>( 1000 );</div><div class="line"></div><div class="line">        <a class="code" href="GpioPinMacros_8h.html#afb3e478c66e48ce826a6727737525bb9">setGpioPinLow</a>( pGreen );</div><div class="line">        <a class="code" href="GpioPinMacros_8h.html#afcd7e66a9c60b13bf749e18304a71ac6">setGpioPinHigh</a>( pYellow );</div><div class="line"></div><div class="line">        <a class="code" href="SystemClock_8h.html#a74d8aff40774c8a364845f0265776a24">delayMilliseconds</a>( 1000 );</div><div class="line"></div><div class="line">        <a class="code" href="GpioPinMacros_8h.html#afb3e478c66e48ce826a6727737525bb9">setGpioPinLow</a>( pYellow );</div><div class="line">        <a class="code" href="GpioPinMacros_8h.html#afcd7e66a9c60b13bf749e18304a71ac6">setGpioPinHigh</a>( pRed );</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="AdvancedGpioVarsExampleVars"></a>
Example using GPIO pin variables</h2>
<p>Compiled for an Arduino Uno, the following program is 2,456 bytes (478 bytes larger than the macro version) and uses an additional 45 bytes of SRAM compared to the macro version.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ArduinoPins_8h.html">AVRTools/ArduinoPins.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="InitSystem_8h.html">AVRTools/InitSystem.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="SystemClock_8h.html">AVRTools/SystemClock.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define pRed            pPin10</span></div><div class="line"><span class="preprocessor">#define pYellow         pPin07</span></div><div class="line"><span class="preprocessor">#define pGreen          pPin04</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="InitSystem_8h.html#ae332dfb8661c411f6d461d4b068ebb81">initSystem</a>();</div><div class="line">    <a class="code" href="SystemClock_8h.html#a81308abf4a2f57e7b17ce1c8e90d4a51">initSystemClock</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classGpioPinVariable.html">GpioPinVariable</a> pins[3];</div><div class="line">    pins[0] = <a class="code" href="GpioPinMacros_8h.html#a30dcbc33f1d98d34c345de2751c2715a">makeGpioVarFromGpioPin</a>( pRed );</div><div class="line">    pins[1] = <a class="code" href="GpioPinMacros_8h.html#a30dcbc33f1d98d34c345de2751c2715a">makeGpioVarFromGpioPin</a>( pYellow );</div><div class="line">    pins[2] = <a class="code" href="GpioPinMacros_8h.html#a30dcbc33f1d98d34c345de2751c2715a">makeGpioVarFromGpioPin</a>( pGreen );</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; 3; i++ )</div><div class="line">    {</div><div class="line">        <a class="code" href="GpioPinMacros_8h.html#a35f1608c15e9ca9aec4a373f65316f94">setGpioPinModeOutputV</a>( pins[i] );</div><div class="line">        <a class="code" href="GpioPinMacros_8h.html#a6a841725322fd84357cefe881710ae57">setGpioPinHighV</a>( pins[i] );</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="SystemClock_8h.html#a74d8aff40774c8a364845f0265776a24">delayMilliseconds</a>( 2000 );</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; 3; i++ )</div><div class="line">    {</div><div class="line">        <a class="code" href="GpioPinMacros_8h.html#a5d844de3e52a8e4643e629b813d0f9ce">setGpioPinLowV</a>( pins[i] );</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> i = 0;</div><div class="line">    <span class="keywordflow">while</span> ( 1 )</div><div class="line">    {</div><div class="line">        <a class="code" href="SystemClock_8h.html#a74d8aff40774c8a364845f0265776a24">delayMilliseconds</a>( 1000 );</div><div class="line"></div><div class="line">        <a class="code" href="GpioPinMacros_8h.html#a5d844de3e52a8e4643e629b813d0f9ce">setGpioPinLowV</a>( pins[i++] );</div><div class="line">        i %= 3;</div><div class="line">        <a class="code" href="GpioPinMacros_8h.html#a6a841725322fd84357cefe881710ae57">setGpioPinHighV</a>( pins[i] );</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 30 2016 12:55:08 for AVRTools by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
