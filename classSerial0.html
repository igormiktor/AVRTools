<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AVRTools: Serial0 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AVRTools
   </div>
   <div id="projectbrief">A Library for the AVR ATmega328 and ATmega2560 Microcontrollers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSerial0-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Serial0 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides a high-end interface to serial communications using USART0.  
 <a href="classSerial0.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="USART0_8h_source.html">USART0.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Serial0:</div>
<div class="dyncontent">
<div class="center"><img src="classSerial0__inherit__graph.png" border="0" usemap="#Serial0_inherit__map" alt="Inheritance graph"/></div>
<map name="Serial0_inherit__map" id="Serial0_inherit__map">
<area shape="rect" id="node2" href="classWriter.html" title="This is an abstract class defining a generic interface to write numbers and strings to a sequential s..." alt="" coords="5,5,63,32"/>
<area shape="rect" id="node3" href="classReader.html" title="This is an abstract class defining a generic interface to read numbers and strings from a sequential ..." alt="" coords="87,5,151,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Serial0:</div>
<div class="dyncontent">
<div class="center"><img src="classSerial0__coll__graph.png" border="0" usemap="#Serial0_coll__map" alt="Collaboration graph"/></div>
<map name="Serial0_coll__map" id="Serial0_coll__map">
<area shape="rect" id="node2" href="classWriter.html" title="This is an abstract class defining a generic interface to write numbers and strings to a sequential s..." alt="" coords="5,5,63,32"/>
<area shape="rect" id="node3" href="classReader.html" title="This is an abstract class defining a generic interface to read numbers and strings from a sequential ..." alt="" coords="87,5,151,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a410a90149b4a74729cac27bfaf7adaa7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7">IntegerOutputBase</a> { <a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a397bd73f41882a6debc744a547e60d1e">kBin</a> = 2, 
<a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a68ddf25620124a08df86f259ed29e070">kOct</a> = 8, 
<a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a> = 10, 
<a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a3da2ebab3b20ef609683f94afd43e944">kHex</a> = 16
 }<tr class="memdesc:a410a90149b4a74729cac27bfaf7adaa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumeration that defines the number that will be used as the base for representing integer quantities as a string of characters.  <a href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a410a90149b4a74729cac27bfaf7adaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1802aaae5416aaca6ca4d67f64ea2412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerial0.html#a1802aaae5416aaca6ca4d67f64ea2412">start</a> (unsigned long baudRate, <a class="el" href="USART0_8h.html#a6827034a5e9f7eca7eb51c23e2679177">UsartSerialConfiguration</a> config=<a class="el" href="USART3_8h.html#a6827034a5e9f7eca7eb51c23e2679177af4ff7f9a62dc9651b2506dc7f0fa581f">kSerial_8N1</a>)</td></tr>
<tr class="memdesc:a1802aaae5416aaca6ca4d67f64ea2412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the hardware for two-way serial communications, including turning on associated interrupts. You must call this function before reading from or writing to <a class="el" href="classSerial0.html" title="Provides a high-end interface to serial communications using USART0. ">Serial0</a> on USART0.  <a href="#a1802aaae5416aaca6ca4d67f64ea2412">More...</a><br /></td></tr>
<tr class="separator:a1802aaae5416aaca6ca4d67f64ea2412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4e883262a411ac3034bc04ad242d68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerial0.html#a2d4e883262a411ac3034bc04ad242d68">stop</a> ()</td></tr>
<tr class="memdesc:a2d4e883262a411ac3034bc04ad242d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops buffered serial communications using <a class="el" href="classSerial0.html" title="Provides a high-end interface to serial communications using USART0. ">Serial0</a> on USART0 by deconfiguring the hardware and turning off interrupts.  <a href="#a2d4e883262a411ac3034bc04ad242d68">More...</a><br /></td></tr>
<tr class="separator:a2d4e883262a411ac3034bc04ad242d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65704242829936990e5797d488459101"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerial0.html#a65704242829936990e5797d488459101">write</a> (char c)</td></tr>
<tr class="memdesc:a65704242829936990e5797d488459101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single character to the output stream. This implements the pure virtual function <a class="el" href="classWriter.html#a568c1c230fe53b04eccc948d432ea3be" title="Pure virtual function that writes a single character to the output stream. ">Writer::write( char c )</a>.  <a href="#a65704242829936990e5797d488459101">More...</a><br /></td></tr>
<tr class="separator:a65704242829936990e5797d488459101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9105972c647e79a041bd85c4d9195e26"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerial0.html#a9105972c647e79a041bd85c4d9195e26">write</a> (const char *str)</td></tr>
<tr class="memdesc:a9105972c647e79a041bd85c4d9195e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a null-terminated string to the output stream. This implements the pure virtual function Writer::write( char* str ).  <a href="#a9105972c647e79a041bd85c4d9195e26">More...</a><br /></td></tr>
<tr class="separator:a9105972c647e79a041bd85c4d9195e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedaedd302338c1ab38da22d6eb6d5fac"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerial0.html#aedaedd302338c1ab38da22d6eb6d5fac">write</a> (const char *buffer, size_t size)</td></tr>
<tr class="memdesc:aedaedd302338c1ab38da22d6eb6d5fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a given number of characters from a buffer to the output stream. This implements the pure virtual function <a class="el" href="classWriter.html#a870117834843655cc62c5340fbbb149d" title="Pure virtual function that writes a given number of characters from a buffer to the output stream...">Writer::write( const char* buffer, size_t size )</a>.  <a href="#aedaedd302338c1ab38da22d6eb6d5fac">More...</a><br /></td></tr>
<tr class="separator:aedaedd302338c1ab38da22d6eb6d5fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543edc1ccf9ae9ac268ddac6ff53d92e"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerial0.html#a543edc1ccf9ae9ac268ddac6ff53d92e">write</a> (const uint8_t *buffer, size_t size)</td></tr>
<tr class="memdesc:a543edc1ccf9ae9ac268ddac6ff53d92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a given number of bytes from a buffer to the output stream. This implements the pure virtual function <a class="el" href="classWriter.html#a560f4c296050095ef4ade4948d7c0098" title="Pure virtual function that writes a given number of bytes from a buffer to the output stream...">Writer::write( const uint8_t* buffer, size_t size )</a>.  <a href="#a543edc1ccf9ae9ac268ddac6ff53d92e">More...</a><br /></td></tr>
<tr class="separator:a543edc1ccf9ae9ac268ddac6ff53d92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbd13f4ce84a661c37dcf4f942b96d0"><td class="memItemLeft" align="right" valign="top"><a id="aafbd13f4ce84a661c37dcf4f942b96d0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerial0.html#aafbd13f4ce84a661c37dcf4f942b96d0">flush</a> ()</td></tr>
<tr class="memdesc:aafbd13f4ce84a661c37dcf4f942b96d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the output stream. When this function returns, all previously written data will have been transmitted through the underlying output stream. This implements the pure virtual function <a class="el" href="classWriter.html#af3a77945c047015364af057d2ac4a95a" title="Pure virtual function to flush the output stream. When this function returns, all previously written ...">Writer::flush()</a>. <br /></td></tr>
<tr class="separator:aafbd13f4ce84a661c37dcf4f942b96d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f6cdf92b103b43340a68896704591a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerial0.html#a03f6cdf92b103b43340a68896704591a">read</a> ()</td></tr>
<tr class="memdesc:a03f6cdf92b103b43340a68896704591a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and remove the next byte from the input stream. This implements the pure virtual function <a class="el" href="classReader.html#aaefe160913f4198ccf2c77642d5cebb7" title="Pure virtual function that reads and removes the next byte from the input stream. ...">Reader::read()</a>.  <a href="#a03f6cdf92b103b43340a68896704591a">More...</a><br /></td></tr>
<tr class="separator:a03f6cdf92b103b43340a68896704591a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfeae70ef3ecbf3cc37ba6b9f3cf286"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerial0.html#afcfeae70ef3ecbf3cc37ba6b9f3cf286">peek</a> ()</td></tr>
<tr class="memdesc:afcfeae70ef3ecbf3cc37ba6b9f3cf286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examine the next byte from the input stream, without removing it. This implements the pure virtual function <a class="el" href="classReader.html#a9c04795621ae56bf60572f5597c8796d" title="Pure virtual function that examines the next byte from the input stream, without removing it...">Reader::peek()</a>.  <a href="#afcfeae70ef3ecbf3cc37ba6b9f3cf286">More...</a><br /></td></tr>
<tr class="separator:afcfeae70ef3ecbf3cc37ba6b9f3cf286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9772ce3965501bc98eeea810552c33e5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerial0.html#a9772ce3965501bc98eeea810552c33e5">available</a> ()</td></tr>
<tr class="memdesc:a9772ce3965501bc98eeea810552c33e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if data is available in the input stream. This implements the pure virtual function <a class="el" href="classReader.html#ad8e214cd7fb18578c8ab0c609d74e939" title="Pure virtual function that determines if data is available in the input stream. ">Reader::available()</a>.  <a href="#a9772ce3965501bc98eeea810552c33e5">More...</a><br /></td></tr>
<tr class="separator:a9772ce3965501bc98eeea810552c33e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882c6b29e77d6654e5abd99e54bee1fd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#a882c6b29e77d6654e5abd99e54bee1fd">print</a> (const char *str, bool addLn=false)</td></tr>
<tr class="memdesc:a882c6b29e77d6654e5abd99e54bee1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a null-terminated string to the output stream, with or without adding a new line character at the end.  <a href="#a882c6b29e77d6654e5abd99e54bee1fd">More...</a><br /></td></tr>
<tr class="separator:a882c6b29e77d6654e5abd99e54bee1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc77d73bdcb82c2de5bb429294f1096"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#a8dc77d73bdcb82c2de5bb429294f1096">print</a> (const uint8_t *buf, size_t size, bool addLn=false)</td></tr>
<tr class="memdesc:a8dc77d73bdcb82c2de5bb429294f1096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a number of bytes to the output stream, with or without adding a new line character at the end.  <a href="#a8dc77d73bdcb82c2de5bb429294f1096">More...</a><br /></td></tr>
<tr class="separator:a8dc77d73bdcb82c2de5bb429294f1096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e42c2f3ccd8457fdb12e2f3ebbb76bc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#a9e42c2f3ccd8457fdb12e2f3ebbb76bc">print</a> (char c, bool addLn=false)</td></tr>
<tr class="memdesc:a9e42c2f3ccd8457fdb12e2f3ebbb76bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a single character to the output stream, with or without adding a new line character at the end.  <a href="#a9e42c2f3ccd8457fdb12e2f3ebbb76bc">More...</a><br /></td></tr>
<tr class="separator:a9e42c2f3ccd8457fdb12e2f3ebbb76bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114ae7bd2e2ba7deba032013aa60754a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#a114ae7bd2e2ba7deba032013aa60754a">print</a> (int8_t n, int base=<a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a>, bool addLn=false)</td></tr>
<tr class="memdesc:a114ae7bd2e2ba7deba032013aa60754a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an 8-bit integer to the output stream, with or without adding a new line character at the end.  <a href="#a114ae7bd2e2ba7deba032013aa60754a">More...</a><br /></td></tr>
<tr class="separator:a114ae7bd2e2ba7deba032013aa60754a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd465bee81087d556b345f65c1a6fba5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#abd465bee81087d556b345f65c1a6fba5">print</a> (uint8_t n, int base=<a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a>, bool addLn=false)</td></tr>
<tr class="memdesc:abd465bee81087d556b345f65c1a6fba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an 8-bit unsigned integer to the output stream, with or without adding a new line character at the end.  <a href="#abd465bee81087d556b345f65c1a6fba5">More...</a><br /></td></tr>
<tr class="separator:abd465bee81087d556b345f65c1a6fba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a37b29b1dabccd34ef6e6323fa9be09"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#a8a37b29b1dabccd34ef6e6323fa9be09">print</a> (int n, int base=<a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a>, bool addLn=false)</td></tr>
<tr class="memdesc:a8a37b29b1dabccd34ef6e6323fa9be09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an integer to the output stream, with or without adding a new line character at the end.  <a href="#a8a37b29b1dabccd34ef6e6323fa9be09">More...</a><br /></td></tr>
<tr class="separator:a8a37b29b1dabccd34ef6e6323fa9be09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a714b6ba4d73e1e020f5ee1e6ee6f6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#a80a714b6ba4d73e1e020f5ee1e6ee6f6">print</a> (unsigned int n, int base=<a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a>, bool addLn=false)</td></tr>
<tr class="memdesc:a80a714b6ba4d73e1e020f5ee1e6ee6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an unsigned integer to the output stream, with or without adding a new line character at the end.  <a href="#a80a714b6ba4d73e1e020f5ee1e6ee6f6">More...</a><br /></td></tr>
<tr class="separator:a80a714b6ba4d73e1e020f5ee1e6ee6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21690d93c4042353168b2f451229116d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#a21690d93c4042353168b2f451229116d">print</a> (long n, int base=<a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a>, bool addLn=false)</td></tr>
<tr class="memdesc:a21690d93c4042353168b2f451229116d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a long integer to the output stream, with or without adding a new line character at the end.  <a href="#a21690d93c4042353168b2f451229116d">More...</a><br /></td></tr>
<tr class="separator:a21690d93c4042353168b2f451229116d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2487475a1a00afcfc55cf86744a611"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#aef2487475a1a00afcfc55cf86744a611">print</a> (unsigned long n, int base=<a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a>, bool addLn=false)</td></tr>
<tr class="memdesc:aef2487475a1a00afcfc55cf86744a611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an unsigned long integer to the output stream, with or without adding a new line character at the end.  <a href="#aef2487475a1a00afcfc55cf86744a611">More...</a><br /></td></tr>
<tr class="separator:aef2487475a1a00afcfc55cf86744a611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b318c44f2cbad145f3c0f52f8f50908"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#a2b318c44f2cbad145f3c0f52f8f50908">print</a> (double d, int digits=2, bool addLn=false)</td></tr>
<tr class="memdesc:a2b318c44f2cbad145f3c0f52f8f50908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a floating point number to the output stream, with or without adding a new line character at the end.  <a href="#a2b318c44f2cbad145f3c0f52f8f50908">More...</a><br /></td></tr>
<tr class="separator:a2b318c44f2cbad145f3c0f52f8f50908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2d135e042d4a90c15d412d1d8818b1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#a2e2d135e042d4a90c15d412d1d8818b1">println</a> (const char *str)</td></tr>
<tr class="memdesc:a2e2d135e042d4a90c15d412d1d8818b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a null-terminated string to the output stream, adding a new line character at the end.  <a href="#a2e2d135e042d4a90c15d412d1d8818b1">More...</a><br /></td></tr>
<tr class="separator:a2e2d135e042d4a90c15d412d1d8818b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a99aacae0dade0297faf4595508be7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#ac3a99aacae0dade0297faf4595508be7">println</a> (const uint8_t *buf, size_t size)</td></tr>
<tr class="memdesc:ac3a99aacae0dade0297faf4595508be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a number of bytes to the output stream, adding a new line character at the end.  <a href="#ac3a99aacae0dade0297faf4595508be7">More...</a><br /></td></tr>
<tr class="separator:ac3a99aacae0dade0297faf4595508be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88553e3da79a0ba4adec78d3abd35c2e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#a88553e3da79a0ba4adec78d3abd35c2e">println</a> (char c)</td></tr>
<tr class="memdesc:a88553e3da79a0ba4adec78d3abd35c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a single character to the output stream, adding a new line character at the end.  <a href="#a88553e3da79a0ba4adec78d3abd35c2e">More...</a><br /></td></tr>
<tr class="separator:a88553e3da79a0ba4adec78d3abd35c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6728ee46ce1c07053573d9574126594"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#aa6728ee46ce1c07053573d9574126594">println</a> (int8_t n, int base=<a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a>)</td></tr>
<tr class="memdesc:aa6728ee46ce1c07053573d9574126594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an 8-bit integer to the output stream, adding a new line character at the end.  <a href="#aa6728ee46ce1c07053573d9574126594">More...</a><br /></td></tr>
<tr class="separator:aa6728ee46ce1c07053573d9574126594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6725a552282ee5dbbc8ce665a8b2191"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#ad6725a552282ee5dbbc8ce665a8b2191">println</a> (uint8_t n, int base=<a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a>)</td></tr>
<tr class="memdesc:ad6725a552282ee5dbbc8ce665a8b2191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an 8-bit unsigned integer to the output stream, adding a new line character at the end.  <a href="#ad6725a552282ee5dbbc8ce665a8b2191">More...</a><br /></td></tr>
<tr class="separator:ad6725a552282ee5dbbc8ce665a8b2191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f74926c3c4fa2896e36e938fe5e24b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#a87f74926c3c4fa2896e36e938fe5e24b">println</a> (int n, int base=<a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a>)</td></tr>
<tr class="memdesc:a87f74926c3c4fa2896e36e938fe5e24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an integer to the output stream, adding a new line character at the end.  <a href="#a87f74926c3c4fa2896e36e938fe5e24b">More...</a><br /></td></tr>
<tr class="separator:a87f74926c3c4fa2896e36e938fe5e24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc70052212a493e63985332dc2061631"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#acc70052212a493e63985332dc2061631">println</a> (unsigned int n, int base=<a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a>)</td></tr>
<tr class="memdesc:acc70052212a493e63985332dc2061631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an unsigned integer to the output stream, adding a new line character at the end.  <a href="#acc70052212a493e63985332dc2061631">More...</a><br /></td></tr>
<tr class="separator:acc70052212a493e63985332dc2061631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a0d07ecb5dfca7b3ab59386ec485a7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#a09a0d07ecb5dfca7b3ab59386ec485a7">println</a> (long n, int base=<a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a>)</td></tr>
<tr class="memdesc:a09a0d07ecb5dfca7b3ab59386ec485a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a long integer to the output stream, adding a new line character at the end.  <a href="#a09a0d07ecb5dfca7b3ab59386ec485a7">More...</a><br /></td></tr>
<tr class="separator:a09a0d07ecb5dfca7b3ab59386ec485a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b281491c71af1d4fcf4ccb368dea4f7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#a0b281491c71af1d4fcf4ccb368dea4f7">println</a> (unsigned long n, int base=<a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a>)</td></tr>
<tr class="memdesc:a0b281491c71af1d4fcf4ccb368dea4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an unsigned long integer to the output stream, adding a new line character at the end.  <a href="#a0b281491c71af1d4fcf4ccb368dea4f7">More...</a><br /></td></tr>
<tr class="separator:a0b281491c71af1d4fcf4ccb368dea4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcae32c461f2f7cef6f22ed9abca7406"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#adcae32c461f2f7cef6f22ed9abca7406">println</a> (double d, int digits=2)</td></tr>
<tr class="memdesc:adcae32c461f2f7cef6f22ed9abca7406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a floating point number to the output stream, adding a new line character at the end.  <a href="#adcae32c461f2f7cef6f22ed9abca7406">More...</a><br /></td></tr>
<tr class="separator:adcae32c461f2f7cef6f22ed9abca7406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc425ca1b6b8e4095ffc37f4be6f873"><td class="memItemLeft" align="right" valign="top"><a id="a2bc425ca1b6b8e4095ffc37f4be6f873"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWriter.html#a2bc425ca1b6b8e4095ffc37f4be6f873">println</a> ()</td></tr>
<tr class="memdesc:a2bc425ca1b6b8e4095ffc37f4be6f873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a new line to the output stream. <br /></td></tr>
<tr class="separator:a2bc425ca1b6b8e4095ffc37f4be6f873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b7865035362c6d866252d93ede9fac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#ad2b7865035362c6d866252d93ede9fac">setTimeout</a> (unsigned long milliseconds)</td></tr>
<tr class="memdesc:ad2b7865035362c6d866252d93ede9fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets maximum milliseconds to wait for stream data, default is 1 second.  <a href="#ad2b7865035362c6d866252d93ede9fac">More...</a><br /></td></tr>
<tr class="separator:ad2b7865035362c6d866252d93ede9fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f3a7286116dcf42dc90fedb8709312"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a86f3a7286116dcf42dc90fedb8709312">find</a> (const char *target)</td></tr>
<tr class="memdesc:a86f3a7286116dcf42dc90fedb8709312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the input stream until the target string is found.  <a href="#a86f3a7286116dcf42dc90fedb8709312">More...</a><br /></td></tr>
<tr class="separator:a86f3a7286116dcf42dc90fedb8709312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6342ede192e7737d45e3c26015f2bab9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a6342ede192e7737d45e3c26015f2bab9">find</a> (const char *target, size_t length)</td></tr>
<tr class="memdesc:a6342ede192e7737d45e3c26015f2bab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the stream until the target string of given length is found.  <a href="#a6342ede192e7737d45e3c26015f2bab9">More...</a><br /></td></tr>
<tr class="separator:a6342ede192e7737d45e3c26015f2bab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01017975b6f066570fe4d01e6bec427c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a01017975b6f066570fe4d01e6bec427c">findUntil</a> (const char *target, const char *terminator)</td></tr>
<tr class="memdesc:a01017975b6f066570fe4d01e6bec427c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the stream until the target string is found, or the terminator string is found, or the function times out.  <a href="#a01017975b6f066570fe4d01e6bec427c">More...</a><br /></td></tr>
<tr class="separator:a01017975b6f066570fe4d01e6bec427c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9666cb5ee6d29d9a7e3e9f08307e60b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#ac9666cb5ee6d29d9a7e3e9f08307e60b">findUntil</a> (const char *target, size_t targetLen, const char *terminate, size_t termLen)</td></tr>
<tr class="memdesc:ac9666cb5ee6d29d9a7e3e9f08307e60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the stream until the target string of given length is found, or the terminator string of given length is found, or the function times out.  <a href="#ac9666cb5ee6d29d9a7e3e9f08307e60b">More...</a><br /></td></tr>
<tr class="separator:ac9666cb5ee6d29d9a7e3e9f08307e60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba74f31b1e1146b0f7c0947303b5f86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a1ba74f31b1e1146b0f7c0947303b5f86">readLong</a> (long *result)</td></tr>
<tr class="memdesc:a1ba74f31b1e1146b0f7c0947303b5f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first valid long integer value from the stream.  <a href="#a1ba74f31b1e1146b0f7c0947303b5f86">More...</a><br /></td></tr>
<tr class="separator:a1ba74f31b1e1146b0f7c0947303b5f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c5bdcaa0321ca320ba77f18b2ddd07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a41c5bdcaa0321ca320ba77f18b2ddd07">readLong</a> (long *result, char skipChar)</td></tr>
<tr class="memdesc:a41c5bdcaa0321ca320ba77f18b2ddd07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first valid long integer value from the stream, ignoring selected characters.  <a href="#a41c5bdcaa0321ca320ba77f18b2ddd07">More...</a><br /></td></tr>
<tr class="separator:a41c5bdcaa0321ca320ba77f18b2ddd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0ceb57268bca02bb2c0b499b8b3ddc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#aeb0ceb57268bca02bb2c0b499b8b3ddc">readFloat</a> (float *result)</td></tr>
<tr class="memdesc:aeb0ceb57268bca02bb2c0b499b8b3ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first valid float value from the stream.  <a href="#aeb0ceb57268bca02bb2c0b499b8b3ddc">More...</a><br /></td></tr>
<tr class="separator:aeb0ceb57268bca02bb2c0b499b8b3ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece0134611d823c6388ab45b53aa2dcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#aece0134611d823c6388ab45b53aa2dcf">readFloat</a> (float *result, char skipChar)</td></tr>
<tr class="memdesc:aece0134611d823c6388ab45b53aa2dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first valid float value from the stream, ignoring selected characters.  <a href="#aece0134611d823c6388ab45b53aa2dcf">More...</a><br /></td></tr>
<tr class="separator:aece0134611d823c6388ab45b53aa2dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1056e1aed49d568e8162a80a20813877"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a1056e1aed49d568e8162a80a20813877">readBytes</a> (char *buffer, size_t length)</td></tr>
<tr class="memdesc:a1056e1aed49d568e8162a80a20813877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read characters from the input stream into a buffer, terminating if length characters have been read or the function times out. The result is <em>NOT</em> null-termimated.  <a href="#a1056e1aed49d568e8162a80a20813877">More...</a><br /></td></tr>
<tr class="separator:a1056e1aed49d568e8162a80a20813877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a74a7a9836c831825971046e09b2018"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a3a74a7a9836c831825971046e09b2018">readBytes</a> (uint8_t *buffer, size_t length)</td></tr>
<tr class="memdesc:a3a74a7a9836c831825971046e09b2018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes (uint8_t) from the input stream into a buffer, terminating if length bytes have been read or the function times out.  <a href="#a3a74a7a9836c831825971046e09b2018">More...</a><br /></td></tr>
<tr class="separator:a3a74a7a9836c831825971046e09b2018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d25170b8a862b911dfe37344b1bf2a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a42d25170b8a862b911dfe37344b1bf2a">readBytesUntil</a> (char terminator, char *buffer, size_t length)</td></tr>
<tr class="memdesc:a42d25170b8a862b911dfe37344b1bf2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read characters from the input stream into a buffer, terminating when the terminator charactor is encountered, or if length characters have been read, or if the function times out. The result is <em>NOT</em> null-terminated.  <a href="#a42d25170b8a862b911dfe37344b1bf2a">More...</a><br /></td></tr>
<tr class="separator:a42d25170b8a862b911dfe37344b1bf2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aef3809b547f08d8ea0ebeb7c19e523"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a6aef3809b547f08d8ea0ebeb7c19e523">readBytesUntil</a> (uint8_t terminator, uint8_t *buffer, size_t length)</td></tr>
<tr class="memdesc:a6aef3809b547f08d8ea0ebeb7c19e523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes (uint8_t) from the input stream into a buffer, terminating when the terminator byte is encountered, or if length bytes have been read, or if the function times out.  <a href="#a6aef3809b547f08d8ea0ebeb7c19e523">More...</a><br /></td></tr>
<tr class="separator:a6aef3809b547f08d8ea0ebeb7c19e523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773c612dc4c8e38ef844e6c110fb4118"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a773c612dc4c8e38ef844e6c110fb4118">readLine</a> (char *buffer, size_t length)</td></tr>
<tr class="memdesc:a773c612dc4c8e38ef844e6c110fb4118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read characters from the input stream into a buffer, until it reaches EOL, or if length characters have been read, or if it times out. The result <em>IS</em> null-termimated.  <a href="#a773c612dc4c8e38ef844e6c110fb4118">More...</a><br /></td></tr>
<tr class="separator:a773c612dc4c8e38ef844e6c110fb4118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dabe8c290c8b97d738f383713f6a0a9"><td class="memItemLeft" align="right" valign="top"><a id="a4dabe8c290c8b97d738f383713f6a0a9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a4dabe8c290c8b97d738f383713f6a0a9">consumeWhiteSpace</a> ()</td></tr>
<tr class="memdesc:a4dabe8c290c8b97d738f383713f6a0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes whitespace characters until the first non-whitespace character is encountered or the function times out. <br /></td></tr>
<tr class="separator:a4dabe8c290c8b97d738f383713f6a0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides a high-end interface to serial communications using USART0. </p>
<p>The functions in this class are buffered for both input and output and operate using interrupts associated with USART0. This means the write functions return immediately after queuing data in the output buffer for transmission and the transmission happens asynchronously, using dedicated USART0 hardware. Similarly, data is received asynchronously and placed into the read buffer.</p>
<p>The read and write buffers are both ring buffers. If you try to queue more data than the transmit buffer can hold, the write functions will block until there is room in the buffer (as a result of data being transmitted). The read buffer, however, will overwrite if it gets full. You must clear the read buffer by actually reading the data regularly when receiving significant amounts of data. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a410a90149b4a74729cac27bfaf7adaa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410a90149b4a74729cac27bfaf7adaa7">&sect;&nbsp;</a></span>IntegerOutputBase</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7">Writer::IntegerOutputBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enumeration that defines the number that will be used as the base for representing integer quantities as a string of characters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a410a90149b4a74729cac27bfaf7adaa7a397bd73f41882a6debc744a547e60d1e"></a>kBin&#160;</td><td class="fielddoc"><p>Produce a binary representation of integers (e.g., 11 is output as 0b1011) </p>
</td></tr>
<tr><td class="fieldname"><a id="a410a90149b4a74729cac27bfaf7adaa7a68ddf25620124a08df86f259ed29e070"></a>kOct&#160;</td><td class="fielddoc"><p>Produce an octal representation of integers (e.g, 11 is output as 013) </p>
</td></tr>
<tr><td class="fieldname"><a id="a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99"></a>kDec&#160;</td><td class="fielddoc"><p>Produce a decimal representation of integers (e.g., 11 is output as 11. </p>
</td></tr>
<tr><td class="fieldname"><a id="a410a90149b4a74729cac27bfaf7adaa7a3da2ebab3b20ef609683f94afd43e944"></a>kHex&#160;</td><td class="fielddoc"><p>Produce a hexadecimal representation of integers (e.g., 11 is output as 0x0b) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9772ce3965501bc98eeea810552c33e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9772ce3965501bc98eeea810552c33e5">&sect;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Serial0::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if data is available in the input stream. This implements the pure virtual function <a class="el" href="classReader.html#ad8e214cd7fb18578c8ab0c609d74e939" title="Pure virtual function that determines if data is available in the input stream. ">Reader::available()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>True if data is available in the stream; false if not. </dd></dl>

<p>Implements <a class="el" href="classReader.html#ad8e214cd7fb18578c8ab0c609d74e939">Reader</a>.</p>

</div>
</div>
<a id="a86f3a7286116dcf42dc90fedb8709312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f3a7286116dcf42dc90fedb8709312">&sect;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Reader::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the input stream until the target string is found. </p>
<ul>
<li><code>target</code> is the string the function seeks in the input stream.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if target string is found before timeout, false otherwise. </dd></dl>

</div>
</div>
<a id="a6342ede192e7737d45e3c26015f2bab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6342ede192e7737d45e3c26015f2bab9">&sect;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Reader::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the stream until the target string of given length is found. </p>
<ul>
<li><code>target</code> is a string, the first length bytes of which the function seeks in the input stream. </li>
<li><code>length</code> is the number of bytes of the string to use for comparison.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if target string of given length is found, false if the function times out before finding the target string. </dd></dl>

</div>
</div>
<a id="a01017975b6f066570fe4d01e6bec427c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01017975b6f066570fe4d01e6bec427c">&sect;&nbsp;</a></span>findUntil() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Reader::findUntil </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>terminator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the stream until the target string is found, or the terminator string is found, or the function times out. </p>
<p>This function is like <a class="el" href="classReader.html#a86f3a7286116dcf42dc90fedb8709312" title="Read data from the input stream until the target string is found. ">find()</a> but the search ends if the terminator string is found first.</p>
<ul>
<li><code>target</code> is the string the function seeks in the input stream. </li>
<li><code>terminator</code> is the string that stops the search.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if target string is found before the terminator is encountered and before the function times out; false otherwise. </dd></dl>

</div>
</div>
<a id="ac9666cb5ee6d29d9a7e3e9f08307e60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9666cb5ee6d29d9a7e3e9f08307e60b">&sect;&nbsp;</a></span>findUntil() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Reader::findUntil </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>targetLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>terminate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>termLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the stream until the target string of given length is found, or the terminator string of given length is found, or the function times out. </p>
<p>This function is like <a class="el" href="classReader.html#a86f3a7286116dcf42dc90fedb8709312" title="Read data from the input stream until the target string is found. ">find()</a> but the search ends if the terminator string is found first.</p>
<ul>
<li><code>target</code> is the string the function seeks in the input stream. </li>
<li><code>targetLen</code> is the number of bytes in target that the function seeks in the input stream. </li>
<li><code>terminator</code> is the string that stops the search. </li>
<li><code>termLen</code> is the number of bytes in the terminator that</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if target string is found before the terminator is encountered and before the function times out; false otherwise. </dd></dl>

</div>
</div>
<a id="afcfeae70ef3ecbf3cc37ba6b9f3cf286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfeae70ef3ecbf3cc37ba6b9f3cf286">&sect;&nbsp;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Serial0::peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examine the next byte from the input stream, without removing it. This implements the pure virtual function <a class="el" href="classReader.html#a9c04795621ae56bf60572f5597c8796d" title="Pure virtual function that examines the next byte from the input stream, without removing it...">Reader::peek()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the next byte, or -1 if there is nothing to read in the input stream before timeout expires. </dd></dl>

<p>Implements <a class="el" href="classReader.html#a9c04795621ae56bf60572f5597c8796d">Reader</a>.</p>

</div>
</div>
<a id="a882c6b29e77d6654e5abd99e54bee1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882c6b29e77d6654e5abd99e54bee1fd">&sect;&nbsp;</a></span>print() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::print </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addLn</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a null-terminated string to the output stream, with or without adding a new line character at the end. </p>
<ul>
<li><code>str</code> is the null-terminated string to output. </li>
<li><code>addLn</code> if true, a new line character is added at the end of the output; the default is false.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="a8dc77d73bdcb82c2de5bb429294f1096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc77d73bdcb82c2de5bb429294f1096">&sect;&nbsp;</a></span>print() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::print </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addLn</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a number of bytes to the output stream, with or without adding a new line character at the end. </p>
<ul>
<li><code>buf</code> is the buffer containing bytes to output. </li>
<li><code>size</code> is the number of bytes from the buffer to output. </li>
<li><code>addLn</code> if true, a new line character is added at the end of the output; the default is false.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="a9e42c2f3ccd8457fdb12e2f3ebbb76bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e42c2f3ccd8457fdb12e2f3ebbb76bc">&sect;&nbsp;</a></span>print() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::print </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addLn</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a single character to the output stream, with or without adding a new line character at the end. </p>
<ul>
<li><code>c</code> is the character to output. </li>
<li><code>addLn</code> if true, a new line character is added at the end of the output; the default is false.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="a114ae7bd2e2ba7deba032013aa60754a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114ae7bd2e2ba7deba032013aa60754a">&sect;&nbsp;</a></span>print() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::print </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code><a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addLn</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an 8-bit integer to the output stream, with or without adding a new line character at the end. </p>
<ul>
<li><code>n</code> is the integer to output. </li>
<li><code>base</code> is the base used to represent the number; should be one of IntegerOutputBase; defaults to decimal representation (kDec). </li>
<li><code>addLn</code> if true, a new line character is added at the end of the output; the default is false.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="abd465bee81087d556b345f65c1a6fba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd465bee81087d556b345f65c1a6fba5">&sect;&nbsp;</a></span>print() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::print </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code><a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addLn</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an 8-bit unsigned integer to the output stream, with or without adding a new line character at the end. </p>
<ul>
<li><code>n</code> is the integer to output. </li>
<li><code>base</code> is the base used to represent the number; should be one of IntegerOutputBase; defaults to decimal representation (kDec). </li>
<li><code>addLn</code> if true, a new line character is added at the end of the output; the default is false.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="a8a37b29b1dabccd34ef6e6323fa9be09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a37b29b1dabccd34ef6e6323fa9be09">&sect;&nbsp;</a></span>print() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::print </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code><a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addLn</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an integer to the output stream, with or without adding a new line character at the end. </p>
<ul>
<li><code>n</code> is the integer to output. </li>
<li><code>base</code> is the base used to represent the number; should be one of IntegerOutputBase; defaults to decimal representation (kDec). </li>
<li><code>addLn</code> if true, a new line character is added at the end of the output; the default is false.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="a80a714b6ba4d73e1e020f5ee1e6ee6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a714b6ba4d73e1e020f5ee1e6ee6f6">&sect;&nbsp;</a></span>print() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::print </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code><a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addLn</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an unsigned integer to the output stream, with or without adding a new line character at the end. </p>
<ul>
<li><code>n</code> is the unsigned integer to output. </li>
<li><code>base</code> is the base used to represent the number; should be one of IntegerOutputBase; defaults to decimal representation (kDec). </li>
<li><code>addLn</code> if true, a new line character is added at the end of the output; the default is false.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="a21690d93c4042353168b2f451229116d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21690d93c4042353168b2f451229116d">&sect;&nbsp;</a></span>print() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::print </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code><a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addLn</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a long integer to the output stream, with or without adding a new line character at the end. </p>
<ul>
<li><code>n</code> is the long integer to output. </li>
<li><code>base</code> is the base used to represent the number; should be one of IntegerOutputBase; defaults to decimal representation (kDec). </li>
<li><code>addLn</code> if true, a new line character is added at the end of the output; the default is false.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="aef2487475a1a00afcfc55cf86744a611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2487475a1a00afcfc55cf86744a611">&sect;&nbsp;</a></span>print() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::print </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code><a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addLn</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an unsigned long integer to the output stream, with or without adding a new line character at the end. </p>
<ul>
<li><code>n</code> is the unsigned long integer to output. </li>
<li><code>base</code> is the base used to represent the number; should be one of IntegerOutputBase; defaults to decimal representation (kDec). </li>
<li><code>addLn</code> if true, a new line character is added at the end of the output; the default is false.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="a2b318c44f2cbad145f3c0f52f8f50908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b318c44f2cbad145f3c0f52f8f50908">&sect;&nbsp;</a></span>print() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::print </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digits</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addLn</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a floating point number to the output stream, with or without adding a new line character at the end. </p>
<ul>
<li><code>d</code> is the floating point number to output. </li>
<li><code>digits</code> is the number of decimal digits to output; the default is 2. </li>
<li><code>addLn</code> if true, a new line character is added at the end of the output; the default is false.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="a2e2d135e042d4a90c15d412d1d8818b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2d135e042d4a90c15d412d1d8818b1">&sect;&nbsp;</a></span>println() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::println </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a null-terminated string to the output stream, adding a new line character at the end. </p>
<ul>
<li><code>str</code> is the null-terminated string to output.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="ac3a99aacae0dade0297faf4595508be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a99aacae0dade0297faf4595508be7">&sect;&nbsp;</a></span>println() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::println </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a number of bytes to the output stream, adding a new line character at the end. </p>
<ul>
<li><code>buf</code> is the buffer containing bytes to output. </li>
<li><code>size</code> is the number of bytes from the buffer to output.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="a88553e3da79a0ba4adec78d3abd35c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88553e3da79a0ba4adec78d3abd35c2e">&sect;&nbsp;</a></span>println() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::println </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a single character to the output stream, adding a new line character at the end. </p>
<ul>
<li><code>c</code> is the character to output.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="aa6728ee46ce1c07053573d9574126594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6728ee46ce1c07053573d9574126594">&sect;&nbsp;</a></span>println() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::println </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code><a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an 8-bit integer to the output stream, adding a new line character at the end. </p>
<ul>
<li><code>n</code> is the integer to output. </li>
<li><code>base</code> is the base used to represent the number; should be one of IntegerOutputBase; defaults to decimal representation (kDec).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="ad6725a552282ee5dbbc8ce665a8b2191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6725a552282ee5dbbc8ce665a8b2191">&sect;&nbsp;</a></span>println() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::println </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code><a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an 8-bit unsigned integer to the output stream, adding a new line character at the end. </p>
<ul>
<li><code>n</code> is the unsigned integer to output. </li>
<li><code>base</code> is the base used to represent the number; should be one of IntegerOutputBase; defaults to decimal representation (kDec).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="a87f74926c3c4fa2896e36e938fe5e24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f74926c3c4fa2896e36e938fe5e24b">&sect;&nbsp;</a></span>println() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::println </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code><a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an integer to the output stream, adding a new line character at the end. </p>
<ul>
<li><code>n</code> is the integer to output. </li>
<li><code>base</code> is the base used to represent the number; should be one of IntegerOutputBase; defaults to decimal representation (kDec).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="acc70052212a493e63985332dc2061631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc70052212a493e63985332dc2061631">&sect;&nbsp;</a></span>println() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::println </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code><a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an unsigned integer to the output stream, adding a new line character at the end. </p>
<ul>
<li><code>n</code> is the unsigned integer to output. </li>
<li><code>base</code> is the base used to represent the number; should be one of IntegerOutputBase; defaults to decimal representation (kDec).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="a09a0d07ecb5dfca7b3ab59386ec485a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a0d07ecb5dfca7b3ab59386ec485a7">&sect;&nbsp;</a></span>println() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::println </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code><a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a long integer to the output stream, adding a new line character at the end. </p>
<ul>
<li><code>n</code> is the long integer to output. </li>
<li><code>base</code> is the base used to represent the number; should be one of IntegerOutputBase; defaults to decimal representation (kDec).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="a0b281491c71af1d4fcf4ccb368dea4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b281491c71af1d4fcf4ccb368dea4f7">&sect;&nbsp;</a></span>println() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::println </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code><a class="el" href="classWriter.html#a410a90149b4a74729cac27bfaf7adaa7a78a6d056427d8babbbc1b57ec00c4b99">kDec</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an unsigned long integer to the output stream, adding a new line character at the end. </p>
<ul>
<li><code>n</code> is the unsigned long integer to output. </li>
<li><code>base</code> is the base used to represent the number; should be one of IntegerOutputBase; defaults to decimal representation (kDec).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="adcae32c461f2f7cef6f22ed9abca7406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcae32c461f2f7cef6f22ed9abca7406">&sect;&nbsp;</a></span>println() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Writer::println </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digits</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a floating point number to the output stream, adding a new line character at the end. </p>
<ul>
<li><code>d</code> is the flaoting point number to output. </li>
<li><code>digits</code> is the number of decimal digits to output; the default is 2.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes sent to the output stream. </dd></dl>

</div>
</div>
<a id="a03f6cdf92b103b43340a68896704591a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f6cdf92b103b43340a68896704591a">&sect;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Serial0::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read and remove the next byte from the input stream. This implements the pure virtual function <a class="el" href="classReader.html#aaefe160913f4198ccf2c77642d5cebb7" title="Pure virtual function that reads and removes the next byte from the input stream. ...">Reader::read()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the next byte, or -1 if there is nothing to read in the input stream before timeout expires. </dd></dl>

<p>Implements <a class="el" href="classReader.html#aaefe160913f4198ccf2c77642d5cebb7">Reader</a>.</p>

</div>
</div>
<a id="a1056e1aed49d568e8162a80a20813877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1056e1aed49d568e8162a80a20813877">&sect;&nbsp;</a></span>readBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Reader::readBytes </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read characters from the input stream into a buffer, terminating if length characters have been read or the function times out. The result is <em>NOT</em> null-termimated. </p>
<ul>
<li><code>buffer</code> a pointer to where the characters read will be stored. </li>
<li><code>length</code> the maximum number of characters to read.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of characters placed in the buffer (0 means no data were read prior to timeout). </dd></dl>

</div>
</div>
<a id="a3a74a7a9836c831825971046e09b2018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a74a7a9836c831825971046e09b2018">&sect;&nbsp;</a></span>readBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Reader::readBytes </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read bytes (uint8_t) from the input stream into a buffer, terminating if length bytes have been read or the function times out. </p>
<ul>
<li><code>buffer</code> a pointer to where the bytes read will be stored. </li>
<li><code>length</code> the maximum number of bytes to read.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes placed in the buffer (0 means no data were read prior to timeout). </dd></dl>

</div>
</div>
<a id="a42d25170b8a862b911dfe37344b1bf2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d25170b8a862b911dfe37344b1bf2a">&sect;&nbsp;</a></span>readBytesUntil() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Reader::readBytesUntil </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>terminator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read characters from the input stream into a buffer, terminating when the terminator charactor is encountered, or if length characters have been read, or if the function times out. The result is <em>NOT</em> null-terminated. </p>
<ul>
<li><code>terminator</code> a character that when encountered causes the function to return. </li>
<li><code>buffer</code> a pointer to where the characters read will be stored. </li>
<li><code>length</code> the maximum number of characters to read.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of characters placed in the buffer (0 means no data were read prior to timeout or detecting the terminator character). </dd></dl>

</div>
</div>
<a id="a6aef3809b547f08d8ea0ebeb7c19e523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aef3809b547f08d8ea0ebeb7c19e523">&sect;&nbsp;</a></span>readBytesUntil() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Reader::readBytesUntil </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>terminator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read bytes (uint8_t) from the input stream into a buffer, terminating when the terminator byte is encountered, or if length bytes have been read, or if the function times out. </p>
<ul>
<li><code>terminator</code> a byte that when encountered causes the function to return. </li>
<li><code>buffer</code> a pointer to where the bytes read will be stored. </li>
<li><code>length</code> the maximum number of bytes to read.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes placed in the buffer (0 means no data were read prior to timeout or detecting the terminator character). </dd></dl>

</div>
</div>
<a id="aeb0ceb57268bca02bb2c0b499b8b3ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0ceb57268bca02bb2c0b499b8b3ddc">&sect;&nbsp;</a></span>readFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Reader::readFloat </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first valid float value from the stream. </p>
<p>Initial characters that are not digits (or the minus sign) are skipped; the float is terminated by the first character that is not a digit.</p>
<ul>
<li><code>result</code> is a pointer to where the float will be stored.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if a valid float is found prior to timeout; false otherwise. </dd></dl>

</div>
</div>
<a id="aece0134611d823c6388ab45b53aa2dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece0134611d823c6388ab45b53aa2dcf">&sect;&nbsp;</a></span>readFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Reader::readFloat </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>skipChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first valid float value from the stream, ignoring selected characters. </p>
<p>Initial characters that are not digits (or the minus sign) are skipped; the float is terminated by the first character that is not a digit and is not one of the skip characters. This allows format characters (typically commas) to be ignored on input.</p>
<ul>
<li><code>result</code> is a pointer to where the float will be stored. </li>
<li><code>skipChar</code> is a character that will be ignored on input.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if a valid float is found prior to timeout; false otherwise. </dd></dl>

</div>
</div>
<a id="a773c612dc4c8e38ef844e6c110fb4118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773c612dc4c8e38ef844e6c110fb4118">&sect;&nbsp;</a></span>readLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Reader::readLine </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read characters from the input stream into a buffer, until it reaches EOL, or if length characters have been read, or if it times out. The result <em>IS</em> null-termimated. </p>
<ul>
<li><code>buffer</code> a pointer to where the characters read will be stored. </li>
<li><code>length</code> the maximum number of characters to read.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of characters placed in the buffer (0 means no data were read prior to timeout or detecting EOL). </dd></dl>

</div>
</div>
<a id="a1ba74f31b1e1146b0f7c0947303b5f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba74f31b1e1146b0f7c0947303b5f86">&sect;&nbsp;</a></span>readLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Reader::readLong </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first valid long integer value from the stream. </p>
<p>Initial characters that are not digits (or the minus sign) are skipped; the integer is terminated by the first character that is not a digit.</p>
<ul>
<li><code>result</code> is a pointer to where the long integer will be stored.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if a valid integer is found prior to timeout; false otherwise. </dd></dl>

</div>
</div>
<a id="a41c5bdcaa0321ca320ba77f18b2ddd07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c5bdcaa0321ca320ba77f18b2ddd07">&sect;&nbsp;</a></span>readLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Reader::readLong </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>skipChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first valid long integer value from the stream, ignoring selected characters. </p>
<p>Initial characters that are not digits (or the minus sign) are skipped; the integer is terminated by the first character that is not a digit and is not one of the skip characters. This allows format characters (typically commas) to be ignored on input.</p>
<ul>
<li><code>result</code> is a pointer to where the long integer will be stored. </li>
<li><code>skipChar</code> is a character that will be ignored on input.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if a valid long integer is found prior to timeout; false otherwise. </dd></dl>

</div>
</div>
<a id="ad2b7865035362c6d866252d93ede9fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b7865035362c6d866252d93ede9fac">&sect;&nbsp;</a></span>setTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Reader::setTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets maximum milliseconds to wait for stream data, default is 1 second. </p>
<ul>
<li><code>milliseconds</code> the length of the timeout period in milliseconds. </li>
</ul>

</div>
</div>
<a id="a1802aaae5416aaca6ca4d67f64ea2412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1802aaae5416aaca6ca4d67f64ea2412">&sect;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Serial0::start </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>baudRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="USART0_8h.html#a6827034a5e9f7eca7eb51c23e2679177">UsartSerialConfiguration</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="USART3_8h.html#a6827034a5e9f7eca7eb51c23e2679177af4ff7f9a62dc9651b2506dc7f0fa581f">kSerial_8N1</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure the hardware for two-way serial communications, including turning on associated interrupts. You must call this function before reading from or writing to <a class="el" href="classSerial0.html" title="Provides a high-end interface to serial communications using USART0. ">Serial0</a> on USART0. </p>
<ul>
<li><code>baudRate</code> the baud rate for the communications, usually one of the following values: 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, or 115200 (although other values below can be specified).</li>
</ul>
<ul>
<li><code>config</code> sets the configuration in term of data bits, parity, and stop bits. If omitted, the default is 8 data bits, no parity, and 1 stop bit. </li>
</ul>

</div>
</div>
<a id="a2d4e883262a411ac3034bc04ad242d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4e883262a411ac3034bc04ad242d68">&sect;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Serial0::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops buffered serial communications using <a class="el" href="classSerial0.html" title="Provides a high-end interface to serial communications using USART0. ">Serial0</a> on USART0 by deconfiguring the hardware and turning off interrupts. </p>
<p>After calling this function, Arduino pins 0 and 1 are released and available for use as ordinary digital pins.</p>
<p>If you want to use <a class="el" href="classSerial0.html" title="Provides a high-end interface to serial communications using USART0. ">Serial0</a> again for communications, you must call <a class="el" href="classSerial0.html#a1802aaae5416aaca6ca4d67f64ea2412" title="Configure the hardware for two-way serial communications, including turning on associated interrupts...">start()</a> again. </p>

</div>
</div>
<a id="a65704242829936990e5797d488459101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65704242829936990e5797d488459101">&sect;&nbsp;</a></span>write() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Serial0::write </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a single character to the output stream. This implements the pure virtual function <a class="el" href="classWriter.html#a568c1c230fe53b04eccc948d432ea3be" title="Pure virtual function that writes a single character to the output stream. ">Writer::write( char c )</a>. </p>
<ul>
<li><code>the</code> character to be written.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written. </dd></dl>

<p>Implements <a class="el" href="classWriter.html#a568c1c230fe53b04eccc948d432ea3be">Writer</a>.</p>

</div>
</div>
<a id="a9105972c647e79a041bd85c4d9195e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9105972c647e79a041bd85c4d9195e26">&sect;&nbsp;</a></span>write() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Serial0::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a null-terminated string to the output stream. This implements the pure virtual function Writer::write( char* str ). </p>
<ul>
<li><code>str</code> the string to be written.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written. </dd></dl>

<p>Implements <a class="el" href="classWriter.html#a8737c57c2a408df1258327c7db091799">Writer</a>.</p>

</div>
</div>
<a id="aedaedd302338c1ab38da22d6eb6d5fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedaedd302338c1ab38da22d6eb6d5fac">&sect;&nbsp;</a></span>write() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Serial0::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a given number of characters from a buffer to the output stream. This implements the pure virtual function <a class="el" href="classWriter.html#a870117834843655cc62c5340fbbb149d" title="Pure virtual function that writes a given number of characters from a buffer to the output stream...">Writer::write( const char* buffer, size_t size )</a>. </p>
<ul>
<li><code>buffer</code> the buffer of characters to write. </li>
<li><code>size</code> the number of characters to write</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written. </dd></dl>

<p>Implements <a class="el" href="classWriter.html#a870117834843655cc62c5340fbbb149d">Writer</a>.</p>

</div>
</div>
<a id="a543edc1ccf9ae9ac268ddac6ff53d92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543edc1ccf9ae9ac268ddac6ff53d92e">&sect;&nbsp;</a></span>write() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Serial0::write </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a given number of bytes from a buffer to the output stream. This implements the pure virtual function <a class="el" href="classWriter.html#a560f4c296050095ef4ade4948d7c0098" title="Pure virtual function that writes a given number of bytes from a buffer to the output stream...">Writer::write( const uint8_t* buffer, size_t size )</a>. </p>
<ul>
<li><code>buffer</code> the buffer of bytes to write. </li>
<li><code>size</code> the number of bytes to write</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written. </dd></dl>

<p>Implements <a class="el" href="classWriter.html#a560f4c296050095ef4ade4948d7c0098">Writer</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="USART0_8h_source.html">USART0.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Nov 19 2017 11:52:11 for AVRTools by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
