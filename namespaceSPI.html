<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>AVRTools: SPI Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AVRTools
   </div>
   <div id="projectbrief">A Library for the AVR ATmega328 and ATmega2560 Microcontrollers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SPI Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This namespace bundles an interface to the SPI hardware subsystem on the AVR ATMega328p (Arduino Uno) and ATMega2560 (Arduino Mega) microcontrollers. It provides logical cohesion for functions implement the Master portion of the SPI protocol and prevents namespace collisions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPI_1_1SPISettings.html">SPISettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that binds settings for configuring SPI transmissions.  <a href="classSPI_1_1SPISettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6b319b8392a89d8ce1121ef2f22bf38c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPI.html#a6b319b8392a89d8ce1121ef2f22bf38c">ByteOrder</a> { <a class="el" href="namespaceSPI.html#a6b319b8392a89d8ce1121ef2f22bf38ca3cb5aeb22df6f6aed3d5c2b9660ddcdb">kLsbFirst</a>, 
<a class="el" href="namespaceSPI.html#a6b319b8392a89d8ce1121ef2f22bf38cafde7bb864047ac747fb9a82dc9739d6d">kMsbFirst</a>
 }</td></tr>
<tr class="memdesc:a6b319b8392a89d8ce1121ef2f22bf38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumeration that defines the byte order for multibyte SPI transmissions.  <a href="namespaceSPI.html#a6b319b8392a89d8ce1121ef2f22bf38c">More...</a><br /></td></tr>
<tr class="separator:a6b319b8392a89d8ce1121ef2f22bf38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405f07c121d93d86385497db869ef073"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPI.html#a405f07c121d93d86385497db869ef073">SpiMode</a> { <a class="el" href="namespaceSPI.html#a405f07c121d93d86385497db869ef073a67bc1ab8352cd749eb4928dbfb82b250">kSpiMode0</a>, 
<a class="el" href="namespaceSPI.html#a405f07c121d93d86385497db869ef073ab1133ddc02530f0f0867de42e96792eb">kSpiMode1</a>, 
<a class="el" href="namespaceSPI.html#a405f07c121d93d86385497db869ef073aff9467324663c0726e94c6283e74a1c5">kSpiMode2</a>, 
<a class="el" href="namespaceSPI.html#a405f07c121d93d86385497db869ef073aff4e70d7cb698541803744265281d928">kSpiMode3</a>
 }</td></tr>
<tr class="memdesc:a405f07c121d93d86385497db869ef073"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumeration that defines the modes available for SPI transmissions.  <a href="namespaceSPI.html#a405f07c121d93d86385497db869ef073">More...</a><br /></td></tr>
<tr class="separator:a405f07c121d93d86385497db869ef073"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a64fcb132bfec5b4d6e5d190064d83d90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPI.html#a64fcb132bfec5b4d6e5d190064d83d90">enable</a> ()</td></tr>
<tr class="memdesc:a64fcb132bfec5b4d6e5d190064d83d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the SPI subsystem for transmission.  <a href="#a64fcb132bfec5b4d6e5d190064d83d90">More...</a><br /></td></tr>
<tr class="separator:a64fcb132bfec5b4d6e5d190064d83d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb912ca88a7391bd1d49a74b4b94cd3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPI.html#aeb912ca88a7391bd1d49a74b4b94cd3f">disable</a> ()</td></tr>
<tr class="memdesc:aeb912ca88a7391bd1d49a74b4b94cd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the SPI subsystem, precluding further transmissions.  <a href="#aeb912ca88a7391bd1d49a74b4b94cd3f">More...</a><br /></td></tr>
<tr class="separator:aeb912ca88a7391bd1d49a74b4b94cd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2f8ee9dc17edbf7d7af7e0b3200a53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPI.html#aac2f8ee9dc17edbf7d7af7e0b3200a53">configure</a> (<a class="el" href="classSPI_1_1SPISettings.html">SPISettings</a> settings)</td></tr>
<tr class="memdesc:aac2f8ee9dc17edbf7d7af7e0b3200a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the configuration of SPI subsystem to match the needs of the system you are going to communicate with.  <a href="#aac2f8ee9dc17edbf7d7af7e0b3200a53">More...</a><br /></td></tr>
<tr class="separator:aac2f8ee9dc17edbf7d7af7e0b3200a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9762564586a02baa41d3c0792c2ee33a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPI.html#a9762564586a02baa41d3c0792c2ee33a">transmit</a> (uint8_t data)</td></tr>
<tr class="memdesc:a9762564586a02baa41d3c0792c2ee33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a single byte using the SPI subsystem.  <a href="#a9762564586a02baa41d3c0792c2ee33a">More...</a><br /></td></tr>
<tr class="separator:a9762564586a02baa41d3c0792c2ee33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0b9c51daa418a40ca07c5399efebff"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPI.html#afd0b9c51daa418a40ca07c5399efebff">transmit16</a> (uint16_t data)</td></tr>
<tr class="memdesc:afd0b9c51daa418a40ca07c5399efebff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a word-sized integer (two bytes) using the SPI subsystem. The order in which the bytes are sent is determined by the bit order configuration that has been set.  <a href="#afd0b9c51daa418a40ca07c5399efebff">More...</a><br /></td></tr>
<tr class="separator:afd0b9c51daa418a40ca07c5399efebff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f57460395be05b937c802557d6690d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPI.html#a12f57460395be05b937c802557d6690d">transmit32</a> (uint32_t data)</td></tr>
<tr class="memdesc:a12f57460395be05b937c802557d6690d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a long-word-sized integer (four bytes) using the SPI subsystem. The order in which the bytes are sent is determined by the bit order configuration that has been set.  <a href="#a12f57460395be05b937c802557d6690d">More...</a><br /></td></tr>
<tr class="separator:a12f57460395be05b937c802557d6690d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab486e6d530e62818b2d1040f9183cac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPI.html#ab486e6d530e62818b2d1040f9183cac7">transmit</a> (uint8_t *buffer, size_t count)</td></tr>
<tr class="memdesc:ab486e6d530e62818b2d1040f9183cac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit an array of bytes using the SPI subsystem. The bytes are transmitted in array order.  <a href="#ab486e6d530e62818b2d1040f9183cac7">More...</a><br /></td></tr>
<tr class="separator:ab486e6d530e62818b2d1040f9183cac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace bundles an interface to the SPI hardware subsystem on the AVR ATMega328p (Arduino Uno) and ATMega2560 (Arduino Mega) microcontrollers. It provides logical cohesion for functions implement the Master portion of the SPI protocol and prevents namespace collisions. </p>
<p>These interfaces are synchronous, based on polling the flag in the SPI status register to determine transmission is complete and refill the transmit register with data. While it is possible to create an interrupt driven, asynchronous interface to the SPI subsystem, SPI-based communications are so fast that interrupt-based implementations are slower than polling by nearly a factor of 2. This is based on actual testing data which you can review <a href="https://www.tablix.org/~avian/blog/archives/2012/06/spi_interrupts_versus_polling/">here</a>. What happens is that SPI can work at half the CPU frequency, which means the CPU can only execute about 16 instructions per byte sent. When the CPU is calling interrupts that often, the overhead of calling the interrupt function dominates, and is greater than the overhead of a simple polling loop.</p>
<p>The AVRTools implementation is based in part on the Arduino Library SPI module. In particular, the <a class="el" href="classSPI_1_1SPISettings.html" title="A class that binds settings for configuring SPI transmissions. ">SPISettings</a> class from the Arduino library is very cleverly and efficiently coded and has been adopted here. The lessons learned by the Arduino library SPI authors in correctly initializing the SPI subsystem have also been incorporated into this implementation. However, the packaging of the interface is somewhat different the AVRTools implementation takes a different approach to deconflicting SPI usage between the main thread of code execution and interrupt code.</p>
<p>The fundamental problem is this: if SPI is used in both the main code and in interrupt code, then it is important to ensure that the SPI "transactions" not be interleaved, that only one SPI "transaction" happen at a time. More specifically, you have to ensure that interrupt code using SPI does not interrupt an on-going SPI transaction in the main thread. The Arduino library achieves this by requiring library users to register any interrupts that use SPI and then requirng users to formally define (via function calls) the beginning and end of an SPI "transaction". The AVRTools library instead provides tools (via the InterruptUtils module) to temporarily suppress selected interrupts while the main thread is executing an SPI transaction. This approach allows more fine-tuned control of interrupt suppression, automatically restores interrupts when the SPI transaction is complete (no risk of a missing "end-of-transaction"), and does it with less overhead and memory footprint than the Arduino SPI library. The following code snippet illustrates how to protect main thread SPI usage from conflicts with SPI usage by two external interrupt handlers:</p>
<div class="fragment"><div class="line">uint8_t send( uint8_t data )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// SPI is used by the interrupt functions that respond to external interrupts 0 and 1,</span></div>
<div class="line">  <span class="comment">// so to prevent clashes, we suppress these two external interrupts for</span></div>
<div class="line">  <span class="comment">// the duration of this function</span></div>
<div class="line">  <a class="code" href="classInterrupts_1_1ExternalOff.html">Interrupts::ExternalOff</a> interruptsOff( <a class="code" href="namespaceInterrupts.html#a5e27a0834f4764f0094317f9fa711f5aade112f38a80df198cf73a484f6480b26">kExternalInterrupt0</a> | <a class="code" href="namespaceInterrupts.html#a5e27a0834f4764f0094317f9fa711f5aa334fa384d3190038494ecd3c1f0aa4f5">kExternalInterrupt1</a> );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Configure SPI</span></div>
<div class="line">  <a class="code" href="namespaceSPI.html#aac2f8ee9dc17edbf7d7af7e0b3200a53">SPI::configure</a>( SPISettings( 4000000, <a class="code" href="namespaceSPI.html#a6b319b8392a89d8ce1121ef2f22bf38ca3cb5aeb22df6f6aed3d5c2b9660ddcdb">SPI::kLsbFirst</a>, <a class="code" href="namespaceSPI.html#a405f07c121d93d86385497db869ef073aff9467324663c0726e94c6283e74a1c5">SPI::kSpiMode2</a> ) );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Set the remote slave SS pin low to initiate a transmission</span></div>
<div class="line">  <a class="code" href="GpioPinMacros_8h.html#afb3e478c66e48ce826a6727737525bb9">setGpioPinLow</a>( pConnectedToSlaveSSpin );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Transmit</span></div>
<div class="line">  uint8_t retVal = <a class="code" href="namespaceSPI.html#a9762564586a02baa41d3c0792c2ee33a">SPI::transmit</a>( data );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Set the remote slave SS pin high to terminate the transmission</span></div>
<div class="line">  <a class="code" href="GpioPinMacros_8h.html#afb3e478c66e48ce826a6727737525bb9">setGpioPinLow</a>( pConnectedToSlaveSSpin );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Interrupts automatically reset when this function exits</span></div>
<div class="line">  <span class="keywordflow">return</span> retVal;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This module implements SPI master mode only. </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a6b319b8392a89d8ce1121ef2f22bf38c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceSPI.html#a6b319b8392a89d8ce1121ef2f22bf38c">SPI::ByteOrder</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An enumeration that defines the byte order for multibyte SPI transmissions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a6b319b8392a89d8ce1121ef2f22bf38ca3cb5aeb22df6f6aed3d5c2b9660ddcdb"></a>kLsbFirst&#160;</td><td class="fielddoc">
<p>Least significant byte first. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6b319b8392a89d8ce1121ef2f22bf38cafde7bb864047ac747fb9a82dc9739d6d"></a>kMsbFirst&#160;</td><td class="fielddoc">
<p>Most significant byte first. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a405f07c121d93d86385497db869ef073"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceSPI.html#a405f07c121d93d86385497db869ef073">SPI::SpiMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An enumeration that defines the modes available for SPI transmissions. </p>
<p>There are four modes controlling whether data is shifted in and out on the rising or falling edge of the data clock signal (called the phase, CPHA), and whether the clock is idle when high or low (called the polarity, CPOL). The four modes are simply the possible combinations of phase and polarity. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a405f07c121d93d86385497db869ef073a67bc1ab8352cd749eb4928dbfb82b250"></a>kSpiMode0&#160;</td><td class="fielddoc">
<p>Phase falling, idle low (CPHA = 0, CPOL = 0) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a405f07c121d93d86385497db869ef073ab1133ddc02530f0f0867de42e96792eb"></a>kSpiMode1&#160;</td><td class="fielddoc">
<p>Phase rising, idle low (CPHA = 1, CPOL = 0) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a405f07c121d93d86385497db869ef073aff9467324663c0726e94c6283e74a1c5"></a>kSpiMode2&#160;</td><td class="fielddoc">
<p>Phase falling, idle high (CPHA = 0, CPOL = 1) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a405f07c121d93d86385497db869ef073aff4e70d7cb698541803744265281d928"></a>kSpiMode3&#160;</td><td class="fielddoc">
<p>Phase rising, idle high (CPHA = 1, CPOL = 1) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aac2f8ee9dc17edbf7d7af7e0b3200a53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SPI::configure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPI_1_1SPISettings.html">SPISettings</a>&#160;</td>
          <td class="paramname"><em>settings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the configuration of SPI subsystem to match the needs of the system you are going to communicate with. </p>
<p>You should always configure the SPI subsystem <em>before</em> transmitting any data. The configuration settings remain in place until a subsequent call to this function or until you disable SPI.</p>
<dl class="section note"><dt>Note</dt><dd>If you are using SPI both from interrupts and from the main thread of execution, you must protect SPI onfigurations and transmissions from interleaving. To do this, disable interrupts in the main thread by using the appropriate objects from InterruptUtils. Interrupts should be disabled starting before setting the configuration until the end of the corresponding data transmission. For example:</dd></dl>
<div class="fragment"><div class="line">uint8_t send( uint8_t data )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// SPI is used by the interrupt functions that respond to external interrupts 0 and 1,</span></div>
<div class="line">  <span class="comment">// so to prevent clashes, we suppress these two external interrupts for</span></div>
<div class="line">  <span class="comment">// the duration of this function</span></div>
<div class="line">  <a class="code" href="classInterrupts_1_1ExternalOff.html">Interrupts::ExternalOff</a> interruptsOff( <a class="code" href="namespaceInterrupts.html#a5e27a0834f4764f0094317f9fa711f5aade112f38a80df198cf73a484f6480b26">kExternalInterrupt0</a> | <a class="code" href="namespaceInterrupts.html#a5e27a0834f4764f0094317f9fa711f5aa334fa384d3190038494ecd3c1f0aa4f5">kExternalInterrupt1</a> );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Configure SPI</span></div>
<div class="line">  <a class="code" href="namespaceSPI.html#aac2f8ee9dc17edbf7d7af7e0b3200a53">SPI::configure</a>( SPISettings( 4000000, <a class="code" href="namespaceSPI.html#a6b319b8392a89d8ce1121ef2f22bf38ca3cb5aeb22df6f6aed3d5c2b9660ddcdb">SPI::kLsbFirst</a>, <a class="code" href="namespaceSPI.html#a405f07c121d93d86385497db869ef073aff9467324663c0726e94c6283e74a1c5">SPI::kSpiMode2</a> ) );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Set the remote slave SS pin low to initiate a transmission</span></div>
<div class="line">  <a class="code" href="GpioPinMacros_8h.html#afb3e478c66e48ce826a6727737525bb9">setGpioPinLow</a>( pConnectedToSlaveSSpin );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Transmit</span></div>
<div class="line">  uint8_t retVal = <a class="code" href="namespaceSPI.html#a9762564586a02baa41d3c0792c2ee33a">SPI::transmit</a>( data );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Set the remote slave SS pin high to terminate the transmission</span></div>
<div class="line">  <a class="code" href="GpioPinMacros_8h.html#afb3e478c66e48ce826a6727737525bb9">setGpioPinLow</a>( pConnectedToSlaveSSpin );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Interrupts automatically reset when this function exits</span></div>
<div class="line">  <span class="keywordflow">return</span> retVal;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aeb912ca88a7391bd1d49a74b4b94cd3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPI::disable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the SPI subsystem, precluding further transmissions. </p>
<p>This call disables the SPI hardware, releasing the MOSI, MISO, CLK, and SS pins for other uses.</p>
<dl class="section note"><dt>Note</dt><dd>No further SPI transmissions should be made after calling this function, unless you re-enable the SPI subsystem by again calling <a class="el" href="namespaceSPI.html#a64fcb132bfec5b4d6e5d190064d83d90" title="Enable the SPI subsystem for transmission. ">enable()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a64fcb132bfec5b4d6e5d190064d83d90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPI::enable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the SPI subsystem for transmission. </p>
<p>This call enables the SPI hardware and configures the MOSI, MISO, CLK, and SS pins, making them unavailable for other uses. It also sets a default configuration of the SPI subsystem to a maximum transmission speed of 8 MHz, most significant bit first, and kSpiMode0.</p>
<dl class="section note"><dt>Note</dt><dd>Even though SPI is configured in master-mode, the configuration of the SS pin is affected. The SS pin is set to output to prevent inadvertent automatic triggering of slave-mode by the SPI hardware (this happens if a low signal is received on the SS pin). Although the SS pin must be in output mode, it can still be used as a general purpose output port (it doesn't affect SPI operations as long as it remains in output mode). </dd></dl>

</div>
</div>
<a class="anchor" id="a9762564586a02baa41d3c0792c2ee33a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SPI::transmit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transmit a single byte using the SPI subsystem. </p>
<ul>
<li><code>data</code> the byte to be transmitted.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the byte received from the SPI subsystem. </dd></dl>

</div>
</div>
<a class="anchor" id="ab486e6d530e62818b2d1040f9183cac7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SPI::transmit </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transmit an array of bytes using the SPI subsystem. The bytes are transmitted in array order. </p>
<ul>
<li><code>buffer</code> the array of bytes to transmit. Incoming bytes are also stored here, replacing the outgoing data, byte-for-byte.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>nothing, but the received stream of bytes is loaded into the buffer, replacing the data originally in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="afd0b9c51daa418a40ca07c5399efebff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t SPI::transmit16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transmit a word-sized integer (two bytes) using the SPI subsystem. The order in which the bytes are sent is determined by the bit order configuration that has been set. </p>
<ul>
<li><code>data</code> the word-sized integer (two bytes) to be transmitted.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the word-sized integer (two bytes) received from the SPI subsystem, with byte order determined by the bit order configuration that has been set. </dd></dl>

</div>
</div>
<a class="anchor" id="a12f57460395be05b937c802557d6690d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SPI::transmit32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a long-word-sized integer (four bytes) using the SPI subsystem. The order in which the bytes are sent is determined by the bit order configuration that has been set. </p>
<ul>
<li><code>data</code> the long-word-sized integer (four bytes) to be transmitted.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the long-word-sized integer(four bytes) received from the SPI subsystem, with byte order determined by the bit order configuration that has been set. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 10 2015 20:37:48 for AVRTools by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
