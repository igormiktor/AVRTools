<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AVRTools: Reader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AVRTools
   </div>
   <div id="projectbrief">A Library for the AVR ATmega328 and ATmega2560 Microcontrollers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classReader-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Reader Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>This is an abstract class defining a generic interface to read numbers and strings from a sequential stream of bytes (such as a serial device).  
 <a href="classReader.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Reader_8h_source.html">Reader.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Reader:</div>
<div class="dyncontent">
<div class="center"><img src="classReader__inherit__graph.png" border="0" usemap="#aReader_inherit__map" alt="Inheritance graph"/></div>
<map name="aReader_inherit__map" id="aReader_inherit__map">
<area shape="rect" title="This is an abstract class defining a generic interface to read numbers and strings from a sequential ..." alt="" coords="134,5,198,31"/>
<area shape="rect" href="classSerial0.html" title="Provides a high&#45;end interface to serial communications using USART0." alt="" coords="5,79,68,104"/>
<area shape="poly" title=" " alt="" coords="134,40,59,81,57,76,132,35"/>
<area shape="rect" href="classSerial1.html" title="Provides a high&#45;end interface to serial communications using USART1." alt="" coords="92,79,155,104"/>
<area shape="poly" title=" " alt="" coords="154,44,133,80,128,77,150,41"/>
<area shape="rect" href="classSerial2.html" title="Provides a high&#45;end interface to serial communications using USART2." alt="" coords="179,79,241,104"/>
<area shape="poly" title=" " alt="" coords="183,41,205,77,201,80,178,44"/>
<area shape="rect" href="classSerial3.html" title="Provides a high&#45;end interface to serial communications using USART3." alt="" coords="265,79,328,104"/>
<area shape="poly" title=" " alt="" coords="201,35,277,76,274,81,198,40"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adcda31b507720ab44044d7a21686fba2" id="r_adcda31b507720ab44044d7a21686fba2"><td class="memItemLeft" align="right" valign="top"><a id="adcda31b507720ab44044d7a21686fba2" name="adcda31b507720ab44044d7a21686fba2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Reader</b> ()</td></tr>
<tr class="memdesc:adcda31b507720ab44044d7a21686fba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. It sets the default timeout to 1 second. <br /></td></tr>
<tr class="separator:adcda31b507720ab44044d7a21686fba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefe160913f4198ccf2c77642d5cebb7" id="r_aaefe160913f4198ccf2c77642d5cebb7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#aaefe160913f4198ccf2c77642d5cebb7">read</a> ()=0</td></tr>
<tr class="memdesc:aaefe160913f4198ccf2c77642d5cebb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function that reads and removes the next byte from the input stream.  <br /></td></tr>
<tr class="separator:aaefe160913f4198ccf2c77642d5cebb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c04795621ae56bf60572f5597c8796d" id="r_a9c04795621ae56bf60572f5597c8796d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a9c04795621ae56bf60572f5597c8796d">peek</a> ()=0</td></tr>
<tr class="memdesc:a9c04795621ae56bf60572f5597c8796d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function that examines the next byte from the input stream, without removing it.  <br /></td></tr>
<tr class="separator:a9c04795621ae56bf60572f5597c8796d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e214cd7fb18578c8ab0c609d74e939" id="r_ad8e214cd7fb18578c8ab0c609d74e939"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#ad8e214cd7fb18578c8ab0c609d74e939">available</a> ()=0</td></tr>
<tr class="memdesc:ad8e214cd7fb18578c8ab0c609d74e939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function that determines if data is available in the input stream.  <br /></td></tr>
<tr class="separator:ad8e214cd7fb18578c8ab0c609d74e939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b7865035362c6d866252d93ede9fac" id="r_ad2b7865035362c6d866252d93ede9fac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#ad2b7865035362c6d866252d93ede9fac">setTimeout</a> (unsigned long milliseconds)</td></tr>
<tr class="memdesc:ad2b7865035362c6d866252d93ede9fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets maximum milliseconds to wait for stream data, default is 1 second.  <br /></td></tr>
<tr class="separator:ad2b7865035362c6d866252d93ede9fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f3a7286116dcf42dc90fedb8709312" id="r_a86f3a7286116dcf42dc90fedb8709312"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a86f3a7286116dcf42dc90fedb8709312">find</a> (const char *target)</td></tr>
<tr class="memdesc:a86f3a7286116dcf42dc90fedb8709312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the input stream until the target string is found.  <br /></td></tr>
<tr class="separator:a86f3a7286116dcf42dc90fedb8709312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6342ede192e7737d45e3c26015f2bab9" id="r_a6342ede192e7737d45e3c26015f2bab9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a6342ede192e7737d45e3c26015f2bab9">find</a> (const char *target, size_t length)</td></tr>
<tr class="memdesc:a6342ede192e7737d45e3c26015f2bab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the stream until the target string of given length is found.  <br /></td></tr>
<tr class="separator:a6342ede192e7737d45e3c26015f2bab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01017975b6f066570fe4d01e6bec427c" id="r_a01017975b6f066570fe4d01e6bec427c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a01017975b6f066570fe4d01e6bec427c">findUntil</a> (const char *target, const char *terminator)</td></tr>
<tr class="memdesc:a01017975b6f066570fe4d01e6bec427c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the stream until the target string is found, or the terminator string is found, or the function times out.  <br /></td></tr>
<tr class="separator:a01017975b6f066570fe4d01e6bec427c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9666cb5ee6d29d9a7e3e9f08307e60b" id="r_ac9666cb5ee6d29d9a7e3e9f08307e60b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#ac9666cb5ee6d29d9a7e3e9f08307e60b">findUntil</a> (const char *target, size_t targetLen, const char *terminate, size_t termLen)</td></tr>
<tr class="memdesc:ac9666cb5ee6d29d9a7e3e9f08307e60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the stream until the target string of given length is found, or the terminator string of given length is found, or the function times out.  <br /></td></tr>
<tr class="separator:ac9666cb5ee6d29d9a7e3e9f08307e60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba74f31b1e1146b0f7c0947303b5f86" id="r_a1ba74f31b1e1146b0f7c0947303b5f86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a1ba74f31b1e1146b0f7c0947303b5f86">readLong</a> (long *result)</td></tr>
<tr class="memdesc:a1ba74f31b1e1146b0f7c0947303b5f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first valid long integer value from the stream.  <br /></td></tr>
<tr class="separator:a1ba74f31b1e1146b0f7c0947303b5f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0ceb57268bca02bb2c0b499b8b3ddc" id="r_aeb0ceb57268bca02bb2c0b499b8b3ddc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#aeb0ceb57268bca02bb2c0b499b8b3ddc">readFloat</a> (float *result)</td></tr>
<tr class="memdesc:aeb0ceb57268bca02bb2c0b499b8b3ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first valid float value from the stream.  <br /></td></tr>
<tr class="separator:aeb0ceb57268bca02bb2c0b499b8b3ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c5bdcaa0321ca320ba77f18b2ddd07" id="r_a41c5bdcaa0321ca320ba77f18b2ddd07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a41c5bdcaa0321ca320ba77f18b2ddd07">readLong</a> (long *result, char skipChar)</td></tr>
<tr class="memdesc:a41c5bdcaa0321ca320ba77f18b2ddd07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first valid long integer value from the stream, ignoring selected characters.  <br /></td></tr>
<tr class="separator:a41c5bdcaa0321ca320ba77f18b2ddd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece0134611d823c6388ab45b53aa2dcf" id="r_aece0134611d823c6388ab45b53aa2dcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#aece0134611d823c6388ab45b53aa2dcf">readFloat</a> (float *result, char skipChar)</td></tr>
<tr class="memdesc:aece0134611d823c6388ab45b53aa2dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first valid float value from the stream, ignoring selected characters.  <br /></td></tr>
<tr class="separator:aece0134611d823c6388ab45b53aa2dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1056e1aed49d568e8162a80a20813877" id="r_a1056e1aed49d568e8162a80a20813877"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a1056e1aed49d568e8162a80a20813877">readBytes</a> (char *buffer, size_t length)</td></tr>
<tr class="memdesc:a1056e1aed49d568e8162a80a20813877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read characters from the input stream into a buffer, terminating if length characters have been read or the function times out. The result is <em>NOT</em> null-termimated.  <br /></td></tr>
<tr class="separator:a1056e1aed49d568e8162a80a20813877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d25170b8a862b911dfe37344b1bf2a" id="r_a42d25170b8a862b911dfe37344b1bf2a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a42d25170b8a862b911dfe37344b1bf2a">readBytesUntil</a> (char terminator, char *buffer, size_t length)</td></tr>
<tr class="memdesc:a42d25170b8a862b911dfe37344b1bf2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read characters from the input stream into a buffer, terminating when the terminator charactor is encountered, or if length characters have been read, or if the function times out. The result is <em>NOT</em> null-terminated.  <br /></td></tr>
<tr class="separator:a42d25170b8a862b911dfe37344b1bf2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a74a7a9836c831825971046e09b2018" id="r_a3a74a7a9836c831825971046e09b2018"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a3a74a7a9836c831825971046e09b2018">readBytes</a> (uint8_t *buffer, size_t length)</td></tr>
<tr class="memdesc:a3a74a7a9836c831825971046e09b2018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes (uint8_t) from the input stream into a buffer, terminating if length bytes have been read or the function times out.  <br /></td></tr>
<tr class="separator:a3a74a7a9836c831825971046e09b2018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aef3809b547f08d8ea0ebeb7c19e523" id="r_a6aef3809b547f08d8ea0ebeb7c19e523"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a6aef3809b547f08d8ea0ebeb7c19e523">readBytesUntil</a> (uint8_t terminator, uint8_t *buffer, size_t length)</td></tr>
<tr class="memdesc:a6aef3809b547f08d8ea0ebeb7c19e523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes (uint8_t) from the input stream into a buffer, terminating when the terminator byte is encountered, or if length bytes have been read, or if the function times out.  <br /></td></tr>
<tr class="separator:a6aef3809b547f08d8ea0ebeb7c19e523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773c612dc4c8e38ef844e6c110fb4118" id="r_a773c612dc4c8e38ef844e6c110fb4118"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReader.html#a773c612dc4c8e38ef844e6c110fb4118">readLine</a> (char *buffer, size_t length)</td></tr>
<tr class="memdesc:a773c612dc4c8e38ef844e6c110fb4118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read characters from the input stream into a buffer, until it reaches EOL, or if length characters have been read, or if it times out. The result <em>IS</em> null-termimated.  <br /></td></tr>
<tr class="separator:a773c612dc4c8e38ef844e6c110fb4118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dabe8c290c8b97d738f383713f6a0a9" id="r_a4dabe8c290c8b97d738f383713f6a0a9"><td class="memItemLeft" align="right" valign="top"><a id="a4dabe8c290c8b97d738f383713f6a0a9" name="a4dabe8c290c8b97d738f383713f6a0a9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>consumeWhiteSpace</b> ()</td></tr>
<tr class="memdesc:a4dabe8c290c8b97d738f383713f6a0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes whitespace characters until the first non-whitespace character is encountered or the function times out. <br /></td></tr>
<tr class="separator:a4dabe8c290c8b97d738f383713f6a0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is an abstract class defining a generic interface to read numbers and strings from a sequential stream of bytes (such as a serial device). </p>
<p>It implements functions to convert a sequence of bytes into various integers and floating point numbers (so it is not a pure interface class). These functions depend on a small set of lower-level functions that are purely abstract and must be implemented by classes deriving from <a class="el" href="classReader.html" title="This is an abstract class defining a generic interface to read numbers and strings from a sequential ...">Reader</a>.</p>
<p><a class="el" href="classSerial0.html" title="Provides a high-end interface to serial communications using USART0.">Serial0</a> is an example of a class that derives from <a class="el" href="classReader.html" title="This is an abstract class defining a generic interface to read numbers and strings from a sequential ...">Reader</a> by implementating the purely abstract functions in <a class="el" href="classReader.html" title="This is an abstract class defining a generic interface to read numbers and strings from a sequential ...">Reader</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Use of the timeout feature requires linking against SystemClock.cpp and calling initSystemClock() from your start-up code. If you do not wish to use the system clock and link against SystemClock.cpp, then define the macro USE_READER_WITHOUT_SYSTEM_CLOCK. This means that calls will never timeout, and you are likely to lock your system if you read input that doesn't naturally terminate parsing (e.g., if you read numbers and the last number isn't followed by a newline). </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad8e214cd7fb18578c8ab0c609d74e939" name="ad8e214cd7fb18578c8ab0c609d74e939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e214cd7fb18578c8ab0c609d74e939">&#9670;&#160;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Reader::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function that determines if data is available in the input stream. </p>
<dl class="section return"><dt>Returns</dt><dd>True if data is available in the stream before timeout expires; false if timeout expires before any data appears in the stream. </dd></dl>

<p>Implemented in <a class="el" href="classSerial0.html#a9772ce3965501bc98eeea810552c33e5">Serial0</a>, <a class="el" href="classSerial1.html#a0eb65788afec24c5320c5ed25465c2eb">Serial1</a>, <a class="el" href="classSerial2.html#a1a5e08d5487feb4ce0f817ef331b9e32">Serial2</a>, and <a class="el" href="classSerial3.html#ad8f3eaeacb8bcffd7610f1d7a060318e">Serial3</a>.</p>

</div>
</div>
<a id="a86f3a7286116dcf42dc90fedb8709312" name="a86f3a7286116dcf42dc90fedb8709312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f3a7286116dcf42dc90fedb8709312">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Reader::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the input stream until the target string is found. </p>
<ul>
<li><code>target</code> is the string the function seeks in the input stream.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if target string is found before timeout, false otherwise. </dd></dl>

</div>
</div>
<a id="a6342ede192e7737d45e3c26015f2bab9" name="a6342ede192e7737d45e3c26015f2bab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6342ede192e7737d45e3c26015f2bab9">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Reader::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the stream until the target string of given length is found. </p>
<ul>
<li><code>target</code> is a string, the first length bytes of which the function seeks in the input stream. </li>
<li><code>length</code> is the number of bytes of the string to use for comparison.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if target string of given length is found, false if the function times out before finding the target string. </dd></dl>

</div>
</div>
<a id="a01017975b6f066570fe4d01e6bec427c" name="a01017975b6f066570fe4d01e6bec427c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01017975b6f066570fe4d01e6bec427c">&#9670;&#160;</a></span>findUntil() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Reader::findUntil </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>terminator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from the stream until the target string is found, or the terminator string is found, or the function times out. </p>
<p>This function is like <a class="el" href="classReader.html#a86f3a7286116dcf42dc90fedb8709312" title="Read data from the input stream until the target string is found.">find()</a> but the search ends if the terminator string is found first.</p>
<ul>
<li><code>target</code> is the string the function seeks in the input stream. </li>
<li><code>terminator</code> is the string that stops the search.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if target string is found before the terminator is encountered and before the function times out; false otherwise. </dd></dl>

</div>
</div>
<a id="ac9666cb5ee6d29d9a7e3e9f08307e60b" name="ac9666cb5ee6d29d9a7e3e9f08307e60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9666cb5ee6d29d9a7e3e9f08307e60b">&#9670;&#160;</a></span>findUntil() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Reader::findUntil </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>targetLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>terminate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>termLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from the stream until the target string of given length is found, or the terminator string of given length is found, or the function times out. </p>
<p>This function is like <a class="el" href="classReader.html#a86f3a7286116dcf42dc90fedb8709312" title="Read data from the input stream until the target string is found.">find()</a> but the search ends if the terminator string is found first.</p>
<ul>
<li><code>target</code> is the string the function seeks in the input stream. </li>
<li><code>targetLen</code> is the number of bytes in target that the function seeks in the input stream. </li>
<li><code>terminator</code> is the string that stops the search. </li>
<li><code>termLen</code> is the number of bytes in the terminator that</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if target string is found before the terminator is encountered and before the function times out; false otherwise. </dd></dl>

</div>
</div>
<a id="a9c04795621ae56bf60572f5597c8796d" name="a9c04795621ae56bf60572f5597c8796d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c04795621ae56bf60572f5597c8796d">&#9670;&#160;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Reader::peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function that examines the next byte from the input stream, without removing it. </p>
<dl class="section return"><dt>Returns</dt><dd>the next byte, or -1 if there is nothing to read in the input stream before timeout expires. </dd></dl>

<p>Implemented in <a class="el" href="classSerial0.html#afcfeae70ef3ecbf3cc37ba6b9f3cf286">Serial0</a>, <a class="el" href="classSerial1.html#a381d2d1e90aaabf1772df2b2347e6207">Serial1</a>, <a class="el" href="classSerial2.html#ae2859a3551d8eed4728682ed5de7aa93">Serial2</a>, and <a class="el" href="classSerial3.html#ac06960b74d99e2e16c37b3d681ea71d5">Serial3</a>.</p>

</div>
</div>
<a id="aaefe160913f4198ccf2c77642d5cebb7" name="aaefe160913f4198ccf2c77642d5cebb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaefe160913f4198ccf2c77642d5cebb7">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Reader::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function that reads and removes the next byte from the input stream. </p>
<dl class="section return"><dt>Returns</dt><dd>the next byte, or -1 if there is nothing to read in the input stream before timeout expires. </dd></dl>

<p>Implemented in <a class="el" href="classSerial0.html#a03f6cdf92b103b43340a68896704591a">Serial0</a>, <a class="el" href="classSerial1.html#a349ffa99cc68894d9049fec666a58256">Serial1</a>, <a class="el" href="classSerial2.html#a05c2a291f63b82f939672214d62c0c3a">Serial2</a>, and <a class="el" href="classSerial3.html#addc2a0e2bb05aa36e33f1954b0de9920">Serial3</a>.</p>

</div>
</div>
<a id="a1056e1aed49d568e8162a80a20813877" name="a1056e1aed49d568e8162a80a20813877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1056e1aed49d568e8162a80a20813877">&#9670;&#160;</a></span>readBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Reader::readBytes </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read characters from the input stream into a buffer, terminating if length characters have been read or the function times out. The result is <em>NOT</em> null-termimated. </p>
<ul>
<li><code>buffer</code> a pointer to where the characters read will be stored. </li>
<li><code>length</code> the maximum number of characters to read.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of characters placed in the buffer (0 means no data were read prior to timeout). </dd></dl>

</div>
</div>
<a id="a3a74a7a9836c831825971046e09b2018" name="a3a74a7a9836c831825971046e09b2018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a74a7a9836c831825971046e09b2018">&#9670;&#160;</a></span>readBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Reader::readBytes </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read bytes (uint8_t) from the input stream into a buffer, terminating if length bytes have been read or the function times out. </p>
<ul>
<li><code>buffer</code> a pointer to where the bytes read will be stored. </li>
<li><code>length</code> the maximum number of bytes to read.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes placed in the buffer (0 means no data were read prior to timeout). </dd></dl>

</div>
</div>
<a id="a42d25170b8a862b911dfe37344b1bf2a" name="a42d25170b8a862b911dfe37344b1bf2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d25170b8a862b911dfe37344b1bf2a">&#9670;&#160;</a></span>readBytesUntil() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Reader::readBytesUntil </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>terminator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read characters from the input stream into a buffer, terminating when the terminator charactor is encountered, or if length characters have been read, or if the function times out. The result is <em>NOT</em> null-terminated. </p>
<ul>
<li><code>terminator</code> a character that when encountered causes the function to return. </li>
<li><code>buffer</code> a pointer to where the characters read will be stored. </li>
<li><code>length</code> the maximum number of characters to read.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of characters placed in the buffer (0 means no data were read prior to timeout or detecting the terminator character). </dd></dl>

</div>
</div>
<a id="a6aef3809b547f08d8ea0ebeb7c19e523" name="a6aef3809b547f08d8ea0ebeb7c19e523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aef3809b547f08d8ea0ebeb7c19e523">&#9670;&#160;</a></span>readBytesUntil() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Reader::readBytesUntil </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>terminator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read bytes (uint8_t) from the input stream into a buffer, terminating when the terminator byte is encountered, or if length bytes have been read, or if the function times out. </p>
<ul>
<li><code>terminator</code> a byte that when encountered causes the function to return. </li>
<li><code>buffer</code> a pointer to where the bytes read will be stored. </li>
<li><code>length</code> the maximum number of bytes to read.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes placed in the buffer (0 means no data were read prior to timeout or detecting the terminator character). </dd></dl>

</div>
</div>
<a id="aeb0ceb57268bca02bb2c0b499b8b3ddc" name="aeb0ceb57268bca02bb2c0b499b8b3ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0ceb57268bca02bb2c0b499b8b3ddc">&#9670;&#160;</a></span>readFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Reader::readFloat </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first valid float value from the stream. </p>
<p>Initial characters that are not digits (or the minus sign) are skipped; the float is terminated by the first character that is not a digit.</p>
<ul>
<li><code>result</code> is a pointer to where the float will be stored.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if a valid float is found prior to timeout; false otherwise. </dd></dl>

</div>
</div>
<a id="aece0134611d823c6388ab45b53aa2dcf" name="aece0134611d823c6388ab45b53aa2dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece0134611d823c6388ab45b53aa2dcf">&#9670;&#160;</a></span>readFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Reader::readFloat </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>skipChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first valid float value from the stream, ignoring selected characters. </p>
<p>Initial characters that are not digits (or the minus sign) are skipped; the float is terminated by the first character that is not a digit and is not one of the skip characters. This allows format characters (typically commas) to be ignored on input.</p>
<ul>
<li><code>result</code> is a pointer to where the float will be stored. </li>
<li><code>skipChar</code> is a character that will be ignored on input.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if a valid float is found prior to timeout; false otherwise. </dd></dl>

</div>
</div>
<a id="a773c612dc4c8e38ef844e6c110fb4118" name="a773c612dc4c8e38ef844e6c110fb4118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773c612dc4c8e38ef844e6c110fb4118">&#9670;&#160;</a></span>readLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Reader::readLine </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read characters from the input stream into a buffer, until it reaches EOL, or if length characters have been read, or if it times out. The result <em>IS</em> null-termimated. </p>
<ul>
<li><code>buffer</code> a pointer to where the characters read will be stored. </li>
<li><code>length</code> the maximum number of characters to read.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of characters placed in the buffer (0 means no data were read prior to timeout or detecting EOL). </dd></dl>

</div>
</div>
<a id="a1ba74f31b1e1146b0f7c0947303b5f86" name="a1ba74f31b1e1146b0f7c0947303b5f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba74f31b1e1146b0f7c0947303b5f86">&#9670;&#160;</a></span>readLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Reader::readLong </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first valid long integer value from the stream. </p>
<p>Initial characters that are not digits (or the minus sign) are skipped; the integer is terminated by the first character that is not a digit.</p>
<ul>
<li><code>result</code> is a pointer to where the long integer will be stored.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if a valid integer is found prior to timeout; false otherwise. </dd></dl>

</div>
</div>
<a id="a41c5bdcaa0321ca320ba77f18b2ddd07" name="a41c5bdcaa0321ca320ba77f18b2ddd07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c5bdcaa0321ca320ba77f18b2ddd07">&#9670;&#160;</a></span>readLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Reader::readLong </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>skipChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first valid long integer value from the stream, ignoring selected characters. </p>
<p>Initial characters that are not digits (or the minus sign) are skipped; the integer is terminated by the first character that is not a digit and is not one of the skip characters. This allows format characters (typically commas) to be ignored on input.</p>
<ul>
<li><code>result</code> is a pointer to where the long integer will be stored. </li>
<li><code>skipChar</code> is a character that will be ignored on input.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if a valid long integer is found prior to timeout; false otherwise. </dd></dl>

</div>
</div>
<a id="ad2b7865035362c6d866252d93ede9fac" name="ad2b7865035362c6d866252d93ede9fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b7865035362c6d866252d93ede9fac">&#9670;&#160;</a></span>setTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Reader::setTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets maximum milliseconds to wait for stream data, default is 1 second. </p>
<ul>
<li><code>milliseconds</code> the length of the timeout period in milliseconds. </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Reader_8h_source.html">Reader.h</a></li>
<li><b>Reader.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
