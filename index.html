<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AVRTools: AVRTools:  A Library for the AVR ATmega328 and ATmega2560 Microcontrollers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AVRTools
   </div>
   <div id="projectbrief">A Library for the AVR ATmega328 and ATmega2560 Microcontrollers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">AVRTools: A Library for the AVR ATmega328 and ATmega2560 Microcontrollers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="AvrOverview"></a>
Overview</h1>
<p>This library provides an Arduino-like simple-to-use interface to the AVR ATmega328 and ATmega2560 microcontrollers without the bloat and slowness of the official Arduino libraries.</p>
<p>AVRTools is an attempt to provide the convenience of the Ardiuno library interface while embracing the fundametal C/C++ philosopy of "you don't pay for what you don't use" and "assume the programmer knows what he or she is doing."</p>
<p>Like the Arduino libraries, AVRTools allows you to refer to pins on an Arduino via simple names such as <code>pPin07</code> for digital pin 7 or <code>pPinA03</code> for analog pin 3. However, unlike the Arduino libraries, these names are pure macros so that <code><a class="el" href="GpioPinMacros_8h.html#afcd7e66a9c60b13bf749e18304a71ac6" title="Write a 1 to the GPIO pin (i.e., set the correspoinding the PORTn bit). ">setGpioPinHigh( pPin12 )</a></code> always translates directly into <code>PORTB |= (1&lt;&lt;PORTB4)</code> on an Arduino Uno. Similar macros are available for conveniently naming any pin on an ATmega328 or ATmega2560, providing easy and efficient access to all the functionality available on that pin (digital I/O, analog-to-digital conversion, PWM, etc). In combination with these pin name macros, AVRTools provides functions to access the major subsystems and functionality of the ATmega328 and ATmega2560 microcontrollers.</p>
<p>On the other hand, because "you don't pay for what you don't use," when using AVRTools nothing is initialized or configured unless you explicitly do it. If you need analog inputs, then you must explicitly initialize the analog-to-digital subsystem before reading any analog pins. If you need an Arduino-style system clock (for functions like <code><a class="el" href="SystemClock_8h.html#a6bc5f943544a887f8b23cadfb26a5e30" title="Delay a certain number of milliseconds. ">delay()</a></code> or <code><a class="el" href="SystemClock_8h.html#a6ff7f2532a22366f0013bc41397129fd" title="Return the number of elasped milliseconds since the system clock was turned on. ">millis()</a></code>), then you must explicitly start a system clock. AVRTools provides functions to do any necessary initialization, but the programmer must explicitly call these function to perform the initialization.</p>
<p>Similarly, because AVRTools "assumes the programmer knows what he or she is doing," it doesn't conduct a lot of checks to ensure you don't do something stupid. For example, when you set the output value of a digital pin using the Arduino library function <code>digitalWrite()</code>, it checks if that pin is currently configured for PWM and if it is, it automatically turns off PWM-mode before writing to the pin. The equivalent of <code>digitalWrite()</code> in the AVRTools library, <code><a class="el" href="GpioPinMacros_8h.html#a18b0e937fe4dd68934585170a9141d4b" title="Write a value the GPIO pin (i.e., set or clear the correspoinding the PORTn bit). ...">writeGpioPinDigital()</a></code> doesn't do that: it assumes that if the programmer previously used the pin in PWM mode that he or she remembered to turn off PWM mode before using the pin digitally. Assuming the programmer knows what he or she is doing allows the functions in AVRTools to be much faster than their Arduino library counterparts. For example, a call to the Arduino function <code>digitalWrite()</code> takes about 70 cycles; a call to the equivalent AVRTools function <code><a class="el" href="GpioPinMacros_8h.html#a18b0e937fe4dd68934585170a9141d4b" title="Write a value the GPIO pin (i.e., set or clear the correspoinding the PORTn bit). ...">writeGpioPinDigital()</a></code> takes 1 cycle (it's actually a macro in AVRTools).</p>
<h1><a class="anchor" id="AvrAudience"></a>
Audience</h1>
<p>If you are an Arduino programmer, you may want to try AVRTools if:</p><ul>
<li>You are comfortable programming the Arduino Uno and Mega directly using the the avr-gcc toolset.</li>
<li>You are frustrated by the slowness of even simple functions in the official Arduino libraries.</li>
<li>Your code doesn't fit into the available memory because the official Arduino libraries are so big.</li>
</ul>
<p>If you are an ATmega328 or ATmega2560 microcontroller programmer, you may want to try AVRTools if:</p><ul>
<li>You are secretly jealous of how easy and convenient it is to use the Arduino libraries.</li>
<li>You wish you could bind together DDRs, PORTs, and PINs so you didn't have to write code like:</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#define MY_PIN_DDR      DDRB</span></div><div class="line"><span class="preprocessor">#define MY_PIN_PORT     PORTB</span></div><div class="line"><span class="preprocessor">#define MY_PIN_PIN      PINB</span></div><div class="line"><span class="preprocessor">#define MY_PIN_NBR      7</span></div><div class="line"></div><div class="line"><span class="comment">/* Put MY_PIN in output mode and set it high */</span></div><div class="line">MY_PIN_DDR |= (1&lt;&lt;MY_PIN_NBR)</div><div class="line">MY_PIN_PORT |= (1&lt;&lt;MY_PIN_NBR)</div></div><!-- fragment --><ul>
<li>You wish you could use a function-like syntax to switch input/output mode, read a pin, or set a pin high or low but still have the compiler generate single-cycle <code>in</code> and <code>out</code> instructions.</li>
</ul>
<p>If you fit into either category, then you should read further.</p>
<h1><a class="anchor" id="AvrToolsIsNot"></a>
AVRTools is not...</h1>
<p>AVRTools is not a general purpose AVR programming library. I use the Arduino Uno and the Arduino Mega in my projects, and I wrote AVRTools to support these specific needs. There is conditional code throughout the implementation that is tailored to the ATmega328 and ATmega2560 microcontrollers. Additional conditional code could be added to create corresponding implementations for other AVR processors in the AT-family, but I haven't done it. Furthermore, the code is written for (and works with) microcontrollers running at either 8 MHz, 12 MHz, or 16 MHz (the code automatically adapts to these three clock speeds). I have not tested any other clock speeds, and some of the delay functions are specifically coded for 8 MHz, 12 MHz, and 16 MHz and will not work (as written) at other clock speeds.</p>
<p>Finally, the AVRTools interface is designed to meet my needs and coding style. That means the interfaces are designed in ways which may not reflect your usage. A particular example of this is the I2C module, which is designed to support the I2C idioms I use in my projects and is significantly different from the I2C interface offered by the Arduino libraries.</p>
<p>AVRTools is a C++ library. People may say that it is crazy to use C++ to program a microcontroller because C++ adds bloat and overhead, because behind your back the C++ compiler adds lots of code to make unnecessary copies, manage heap objects, handle exceptions, etc. C++, much like C, is a language that rewards programmers who know what they are doing and punishes those who don't. One can use C++ because it is a "better C" and use C++ features without incurring performance penalties or code bloat. For example, AVRTools uses namespaces to compartmentalize functionality into logical units and avoid name clashes; AVRTools also uses classes in a few cases where objects provide the most natural and convenient implementation of a capability (for example, certain advanced output classes such as <code><a class="el" href="namespaceUSART0.html" title="This namespace bundles a high-level buffered interface to the USART0 hardware. It provides logical co...">USART0</a></code> or <code><a class="el" href="classI2cLcd.html" title="This class provides a high-level interface via I2C to an LCD such as those offered by AdaFruit and Sp...">I2cLcd</a></code>; note that AVRTools also provides a minimalistic USART interface using functions instead of classes, because different needs call for different tools).</p>
<h1><a class="anchor" id="QuickTour"></a>
Quick Tour of AVRTools</h1>
<p>This section provides an overview of how AVRTools works, starting with the foundational elements and then summarizing the modules that provide interfaces into the major hardware subsystems of the ATmega328 and ATmega2560 microcontrollers.</p>
<h2><a class="anchor" id="Foundations"></a>
Foundational Elements and Concepts</h2>
<p>The foundation of the AVRTools library consists of a collection of macros that enable you to refer to "pins" on the chips using a single name that can be used to switch input/output mode, read, or write a pin. This single name provides access, as appropriate, to the DDRx, PORTx, PINx registers and also the specific pin number. For pins that support analog-to-digital conversion, the single name also provides access the analog channel associated with the pin. For pins that support PWM, the single name also provides access to the control and compare registers and bits needed to configure and control the PWM functionality of that pin.</p>
<p>This is all done via preprocessor macros, both for the single pin name mechanism and for the "functions" that make use of that single pin name. This means that access to any pin-related functionality is as fast as possible, designed specifically so that the <code>avr-gcc</code> compiler will emit single-cycle <code>in</code>, <code>out</code>, <code>sbi</code>, <code>cbi</code>, <code>sbic</code>, or <code>sbis</code> instructions for such operations whenever possible. However, the complex internal representation of the macros means that the pin names are strictly constant and can only be passed to the specialized macro-functions designed to manipulate them. Although they may look and feel like simple constants, pin names cannot be assigned to variables, or passed to ordinary C/C++ functions (however, see the <a class="el" href="AdvancedFeatures.html#AdvancedGpioVars">GPIO Pin Variables section</a> in the <a class="el" href="AdvancedFeatures.html">Advanced Features</a> section for a way to create and use variables for the GPIO pins). The AVRTools library does include macro-functions to extract any of the components related to a pin name so that users can access and manipulate the individual components as needed.</p>
<h2><a class="anchor" id="WhatNeedKnow"></a>
What you need to know about pin name macros</h2>
<p>To access the pin names of the Arduino Uno or Mega, you only need to include the file "ArduinoPins.h". It will automatically detect whether you are compiling for Uno or Mega and it will correspondingly define the macros <code>pPinNN</code> (NN = 00 to 13 for Arduino Uno, NN = 00 to 53 for Mega) for digital ports and macros <code>pPinAnn</code> (nn = 00 to 07 for Uno, nn = 00 to 15 for Mega) for the analog ports. These correspond directly to the labelled pins on the Arduino boards. You can use these pin names to define your own macros:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define THE_RED_LED             pPin12      // Red LED on Arduino pin 12</span></div><div class="line"><span class="preprocessor">#define THE_GRN_LED             pPin11      // Green LED on Arduino pin 11</span></div><div class="line"><span class="preprocessor">#define POTENTIOMETER           pPinA03     // Potentiometer on Arduino pin A3</span></div></div><!-- fragment --><p>While you cannot assign these to pin names to variables or pass them to ordinary functions, AVRTools provides a large collection of macro-functions to operate on the pin names. These include:</p>
<ul>
<li><code><a class="el" href="GpioPinMacros_8h.html#a8802f2fa85c2db869518a49ca6313d84" title="Set the mode of the GPIO pin to output (i.e., set the corresponding DDRn bit). ">setGpioPinModeOutput( pin )</a></code> Enable the corresponding DDRn bit</li>
<li><code><a class="el" href="GpioPinMacros_8h.html#a9e2956fa31869c862cc8ab76f8eec439" title="Set the mode of the GPIO pin to input (i.e., clear the corresponding DDRn and PORTn bits)...">setGpioPinModeInput( pin )</a></code> Clear the corresponding DDRn bit</li>
<li><code><a class="el" href="GpioPinMacros_8h.html#a4bcd394397732af80f460f0a74d423fc" title="Set the mode of the GPIO pin to input with pullup (i.e., clear the corresponding DDRn bit and set the...">setGpioPinModeInputPullup( pin )</a></code> Clear the corresponding DDRn and PORTn bits</li>
<li><code><a class="el" href="GpioPinMacros_8h.html#a9b8f9345e37f8122fc8d71fdcb9147b5" title="Test if the mode of the GPIO pin is output (i.e., the corresponding DDRn bit is set). ">isGpioPinModeOutput( pin )</a></code> Is the corresponding DDRn bit set?</li>
<li><code><a class="el" href="GpioPinMacros_8h.html#a80d626fa0cfee642acf7bbc78db91c7b" title="Test if the mode of the GPIO pin is input (i.e., the corresponding DDRn is clear). ">isGpioPinModeInput( pin )</a></code> Is the corresponding DDRn bit clear?</li>
<li><code><a class="el" href="GpioPinMacros_8h.html#a270fde2ca2cee11cee443221aadfaf3b" title="Read the value of the GPIO pin (i.e., return the value of correspoinding the PINn bit)...">readGpioPinDigital( pin )</a></code> Is the corresponding PINn bit is set? (returns zero or non-zero)</li>
<li><code><a class="el" href="GpioPinMacros_8h.html#a18b0e937fe4dd68934585170a9141d4b" title="Write a value the GPIO pin (i.e., set or clear the correspoinding the PORTn bit). ...">writeGpioPinDigital( pin, value )</a></code> Write a 0 or 1 to the corresponding PORTn bit</li>
<li><code><a class="el" href="GpioPinMacros_8h.html#afcd7e66a9c60b13bf749e18304a71ac6" title="Write a 1 to the GPIO pin (i.e., set the correspoinding the PORTn bit). ">setGpioPinHigh( pin )</a></code> Set the corresponding PORTn bit</li>
<li><code><a class="el" href="GpioPinMacros_8h.html#afb3e478c66e48ce826a6727737525bb9" title="Write a 0 the GPIO pin (i.e., clear the correspoinding the PORTn bit). ">setGpioPinLow( pin )</a></code> Clear the corresponding PORTn bit</li>
<li><code><a class="el" href="Analog2Digital_8h.html#a5043f69bc6307a1ada6ae3819ec11ff7" title="Read the analog value of the pin. ">readGpioPinAnalog( pin )</a></code> Read an analog value from the corresponding ADC channel</li>
<li><code><a class="el" href="Pwm_8h.html#ad374c393f924ead532f5a0cd9e390d40" title="Write a PWM value to a pin. ">writeGpioPinPwm( pin, value )</a></code> Set the corresponding PWM output level for that pin</li>
</ul>
<p>Most of these macros are automatically defined when you include "ArduinoPins.h", although to define the last two you need to include "Analog2Digital.h" and "Pwm.h" (respectively). These macros allow you to write code such as:</p>
<div class="fragment"><div class="line"><span class="comment">// Assuming everything has been initialized properly before this point</span></div><div class="line"></div><div class="line"><a class="code" href="GpioPinMacros_8h.html#a8802f2fa85c2db869518a49ca6313d84">setGpioPinModeOutput</a>( THE_RED_LED );</div><div class="line"><a class="code" href="GpioPinMacros_8h.html#afb3e478c66e48ce826a6727737525bb9">setGpioPinLow</a>( THE_RED_LED );</div><div class="line"></div><div class="line"><a class="code" href="GpioPinMacros_8h.html#a8802f2fa85c2db869518a49ca6313d84">setGpioPinModeOutput</a>( THE_GRN_LED );</div><div class="line"><a class="code" href="GpioPinMacros_8h.html#afb3e478c66e48ce826a6727737525bb9">setGpioPinLow</a>( THE_GRN_LED );</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> ( <a class="code" href="Analog2Digital_8h.html#a5043f69bc6307a1ada6ae3819ec11ff7">readGpioPinAnalog</a>( POTENTIOMETER ) &lt; 100 )</div><div class="line">{</div><div class="line">    <a class="code" href="GpioPinMacros_8h.html#afcd7e66a9c60b13bf749e18304a71ac6">setGpioPinHigh</a>( THE_RED_LED );</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    <a class="code" href="GpioPinMacros_8h.html#afcd7e66a9c60b13bf749e18304a71ac6">setGpioPinHigh</a>( THE_GRN_LED );</div><div class="line">}</div></div><!-- fragment --><p>If you are working directly with an AVR ATmega328 or ATmega2560, you can define pin macros yourself by including "GpioPinMacros.h" (this file is automatically included for you when you include "ArduinoPins.h" if you are working on Arduinos) and using one of three pin naming macros:</p>
<ul>
<li><code><a class="el" href="GpioPinMacros_8h.html#a26d39acd45b82361f0baf73e505eb315" title="Primary macro-function for defining a GPIO pin name. ">GpioPin( letter, number )</a></code> An ordinary pin located on bank <code>letter</code> and bit <code>number</code>; for example the macro <code><a class="el" href="GpioPinMacros_8h.html#a26d39acd45b82361f0baf73e505eb315" title="Primary macro-function for defining a GPIO pin name. ">GpioPin( B, 5 )</a></code> corresponds to pin PB5.</li>
<li><code><a class="el" href="GpioPinMacros_8h.html#aa6d03fd07a19736f078173b08f1bd0c5" title="Secondary macro-function for defining a GPIO pin name for GPIO pins that support analog conversion...">GpioPinAnalog( letter, number, channel )</a></code> An ADC capable pin on bank <code>letter</code> and bit <code>number</code> with ADC <code>channel</code>, e.g., <code><a class="el" href="GpioPinMacros_8h.html#aa6d03fd07a19736f078173b08f1bd0c5" title="Secondary macro-function for defining a GPIO pin name for GPIO pins that support analog conversion...">GpioPinAnalog( C, 5, 5 )</a></code> for Atmega328 pin PC5/ADC5.</li>
<li><code><a class="el" href="GpioPinMacros_8h.html#a9781f1f00f208be7fe33c5cf481a273a" title="Secondary macro-function for defining a GPIO pin name for GPIO pins that support PWM output...">GpioPinPwm( letter, number, timer, channel )</a></code> A PWM capable pin on bank <code>letter</code> and bit <code>number</code> with <code>timer</code> and <code>channel</code> used to select the appropriate OCRn[A/B], TCCRnA registers, and COMn[A/B]1 bits needed to configure the PWM settings, e.g., <a class="el" href="GpioPinMacros_8h.html#a9781f1f00f208be7fe33c5cf481a273a" title="Secondary macro-function for defining a GPIO pin name for GPIO pins that support PWM output...">GpioPinPwm( B, 2, 1, B )</a> for ATmega328 pin PB2/OC1B.</li>
</ul>
<p>So for example, pin 11 on the Arduino Uno, which corresponds to ATmega328 pin B3 which is PWM capable using OC2A, would be defined as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define pPin11  GpioPinPwm( B, 3, 2, A )</span></div></div><!-- fragment --><h2><a class="anchor" id="CodeModules"></a>
The core modules</h2>
<p>In addition to the macro-based pin naming and access system discussed above, there are seven additional elements that make up the core of AVRTools and provide access to basic functional elements of the ATmega328 and ATmega2560 microcontrollers. Together, these provide an Arduino-like interface to the microcontroller features. Five of the seven modules directly interface to microcontroller capabilities:</p>
<ul>
<li><a class="el" href="index.html#SysInit">System initialization module</a></li>
<li><a class="el" href="index.html#SysClock">System clock module</a></li>
<li><a class="el" href="index.html#A2dMod">Analog-to-Digital module</a></li>
<li><a class="el" href="index.html#PwmMod">PWM module</a></li>
<li><a class="el" href="index.html#MinUsart">Minimal USART modules</a></li>
</ul>
<p>Two of the seven modules supplement the C++ implementation provided by the <code>avr-gcc</code> toolset:</p>
<ul>
<li><a class="el" href="index.html#AbiMod">ABI module</a> (support for the C++ ABI not included in the <code>avr-gcc</code> distribution)</li>
<li><a class="el" href="index.html#NewMod">New module</a> (implementation for <code>operator new</code> and <code>operator delete</code>)</li>
</ul>
<p>Brief descriptions of these modules follow.</p>
<h3><a class="anchor" id="SysInit"></a>
System initialization module</h3>
<p>This module provides a single function that puts the microcontroller in a clean, known state. To use it include the header file <code><a class="el" href="InitSystem_8h.html" title="Include this file to use the functions that initialize the microcontroller to a known, basic state. ">InitSystem.h</a></code> and link against <code>InitSystem.cpp</code>. These files provides a single function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="InitSystem_8h.html#ae332dfb8661c411f6d461d4b068ebb81">initSystem</a>();</div></div><!-- fragment --><p>The <code><a class="el" href="InitSystem_8h.html#ae332dfb8661c411f6d461d4b068ebb81" title="This function initializes the microcontroller by clearing any bootloader settings, clearing all timers, and turning on interrupts. ">initSystem()</a></code> function clears any bootloader settings, clears all timers, and turns on interrupts. This should be the first function your code calls at start up.</p>
<h3><a class="anchor" id="SysClock"></a>
System clock module</h3>
<p>This module provides a system clock functionality similar to that in the Arduino library. To employ this functionality include the header file <code><a class="el" href="SystemClock_8h.html" title="Include this file to use the functions that instantiate and access a system clock that counts elapsed...">SystemClock.h</a></code> and link against <code>SystemClock.cpp</code>. Some of key functions provided by this module include:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="SystemClock_8h.html#a81308abf4a2f57e7b17ce1c8e90d4a51">initSystemClock</a>();</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="SystemClock_8h.html#a6ff7f2532a22366f0013bc41397129fd">millis</a>();</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="SystemClock_8h.html#a74d8aff40774c8a364845f0265776a24">delayMilliseconds</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ms );</div></div><!-- fragment --><p>Note that unlike the Arduino libary, you must explicitly initialize the clock functionality by calling <code><a class="el" href="SystemClock_8h.html#a81308abf4a2f57e7b17ce1c8e90d4a51" title="This function initializes a system clock that tracks elapsed milliseconds. ">initSystemClock()</a></code>. This module also provides additional functions providing a richer interface to the system clock.</p>
<h3><a class="anchor" id="A2dMod"></a>
Analog-to-Digital module</h3>
<p>This module provides access to the analog read capabilities of the ATmega328 and ATmega2560. To employ this functionality include the header file <code><a class="el" href="Analog2Digital_8h.html" title="This file provides functions that access the analog-to-digital conversion capability of the ATmega328...">Analog2Digital.h</a></code> and link against <code>Analog2Digital.cpp</code>. The principle functions provided by this module include:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="Analog2Digital_8h.html#a1b09818d247959d12d61655cd0b7101f">initA2D</a>();</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="Analog2Digital_8h.html#a164c6dc4eaff35b5e2ff15ca580fc39a">turnOffA2D</a>();</div><div class="line"><a class="code" href="Analog2Digital_8h.html#a5043f69bc6307a1ada6ae3819ec11ff7">readGpioPinAnalog</a>( pinName );   <span class="comment">/* implemented as a macro */</span></div></div><!-- fragment --><p>You must initialize the analog-to-digital subsystem by calling <code><a class="el" href="Analog2Digital_8h.html#a1b09818d247959d12d61655cd0b7101f" title="Initialize the analog-to-digital system. ">initA2D()</a></code> before attempting to read any analog pins.</p>
<h3><a class="anchor" id="PwmMod"></a>
PWM module</h3>
<p>This module provides access to the PWM features available on certain ATmega328 and ATmega2560 pins. To employ this functionality include the header file <code><a class="el" href="Pwm_8h.html" title="This file provides functions that access the PWM capability of the ATmega328 and ATmega2560 microcont...">Pwm.h</a></code> and link against <code>Pwm.cpp</code>. The principle functions provided by this module include (among others):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="Pwm_8h.html#ab214d170b67f48bd833afaed9a1ec4fa">initPwmTimer1</a>();</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="Pwm_8h.html#af17c680cb05ffeb1312527c320870cbe">initPwmTimer2</a>();</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="Pwm_8h.html#ab8cde6c83419b779cfff6f664d2d3915">clearTimer1</a>();</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="Pwm_8h.html#acaabfa95ecabc23d51e8b41b7f37bc52">clearTimer2</a>();</div><div class="line"><a class="code" href="Pwm_8h.html#ad374c393f924ead532f5a0cd9e390d40">writeGpioPinPwm</a>( pinName, value );  <span class="comment">/* implemented as a macro */</span></div></div><!-- fragment --><p>Depending on which pins you wish to employ in PWM mode, you should initialize the appropriate timers by calling the appropriate <code>initPwmTimerN()</code> function (where <code>N</code> is the appropriate timer number) before writing to the pin in PWM mode. This module also includes additional functions to access the extended PWM capabilities of the ATmega2560. The philosophical difference between the standard Arduino library and AVRTools is evident in this module: none of these function try to deduce which timers need to be turned on for any given pin, because that would require adding extra code and look-up tables. Instead AVRTools assumes the programmer will check the appropriate references to determine which timers correspond to the pins they want to use in PWM mode, and will use that knowledge to initialize the appropriate timers. For convenience, tables of PWM-capable pins and corresponding timers are included in the <code><a class="el" href="Pwm_8h.html" title="This file provides functions that access the PWM capability of the ATmega328 and ATmega2560 microcont...">Pwm.h</a></code> documentation.</p>
<h3><a class="anchor" id="MinUsart"></a>
Minimal USART modules</h3>
<p>These modules provide basic functionality for reading and writing from the USARTs available on the ATmega328 and ATmega2560. To employ the USART0 functionality, you must include the header file <code><a class="el" href="USART0Minimal_8h.html" title="This file provides functions that provide a minimalist interface to USART0 available on the Arduino U...">USART0Minimal.h</a></code> and link against the file <code>USART0Minimal.cpp</code>. The principle functions for accessing the USARTs are:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="USART0Minimal_8h.html#a0007c3d50eaf3a8c1b92d2ea0b681fb1">initUSART0</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> baudRate );</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="USART0Minimal_8h.html#a4b3f1118bf21ff46625919343b0b9d9d">transmitUSART0</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> data );</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="USART0Minimal_8h.html#a4b3f1118bf21ff46625919343b0b9d9d">transmitUSART0</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* data );</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="USART0Minimal_8h.html#ab8088594df45071a7b3ab6f9c9eba433">receiveUSART0</a>();</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="USART0Minimal_8h.html#a3e99fdd93a3ace96152127ac994d419d">releaseUSART0</a>();</div></div><!-- fragment --><p>To make use of the USART0 capability, first call <code><a class="el" href="USART0Minimal_8h.html#a0007c3d50eaf3a8c1b92d2ea0b681fb1" title="Initialize USART0 for serial receive and transmit. ">initUSART0()</a></code> to initialize the USART. Then you can use <code><a class="el" href="USART0Minimal_8h.html#a4b3f1118bf21ff46625919343b0b9d9d" title="Transmit a single byte on USART0. ">transmitUSART0()</a></code> and <code><a class="el" href="USART0Minimal_8h.html#ab8088594df45071a7b3ab6f9c9eba433" title="Receive a byte on USART0. ">receiveUSART0()</a></code> functions to communicate on USART0. When you are done with USART0 and want to use pins 0 and 1 for other purposes, call <code><a class="el" href="USART0Minimal_8h.html#a3e99fdd93a3ace96152127ac994d419d" title="Release USART0, making pins 0 and 1 again available for non-USART use. ">releaseUSART0()</a></code>. Similar functions are provided to access the other three USARTs available on the ATmega2560; simply include <code>USARTnMinimal.h</code> and link against the file <code>USARTnMinimal.cpp</code>, where <code>n = 1, 2,</code> or <code>3</code>. If you want more advanced serial capabilities, checkout the class <a class="el" href="classSerial0.html" title="Provides a high-end interface to serial communications using USART0. ">Serial0</a> in <code><a class="el" href="USART0_8h.html" title="This file provides functions that offer high-level interfaces to USART0 hardware, which is available ...">USART0.h</a></code>.</p>
<h3><a class="anchor" id="AbiMod"></a>
ABI module</h3>
<p>You only need this module if building your code produces link errors regarding missing symbols with strange names like <code>__cxa_XXX</code> (where <code>XXX</code> is some unusual string). In that case, simply link your code against <code>abi.cpp</code>. These are symbols related to the way the avr-gcc C++ compiler implements abstract virtual functions.</p>
<h3><a class="anchor" id="NewMod"></a>
New module</h3>
<p>This module implements <code>operator new</code> and <code>operator delete</code>. You only need this if you use <code>new</code> and <code>delete</code> to manage objects on the heap. Link against <code>new.cpp</code> to make use of these operators. AVRTools itself does not make any use of heap objects or operators <code>new</code> or <code>delete</code>.</p>
<h1><a class="anchor" id="SampleStartCode"></a>
Sample start up code using AVRTools</h1>
<p>You can use AVRTools to create an environment that is very similar to the standard Arduino environment. The following sample code illustrates how to do this. The sample code reads a potentiometer and sets both a digital pin and a PWM pin based on the value of the potentiometer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ArduinoPins_8h.html">AVRTools/ArduinoPins.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="InitSystem_8h.html">AVRTools/InitSystem.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="SystemClock_8h.html">AVRTools/SystemClock.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="Analog2Digital_8h.html">AVRTools/Analog2Digital.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="Pwm_8h.html">AVRTools/Pwm.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define pPot            pPinA01</span></div><div class="line"><span class="preprocessor">#define pPwmLed         pPin11</span></div><div class="line"><span class="preprocessor">#define pLed            pPin04</span></div><div class="line"></div><div class="line">init main()</div><div class="line">{</div><div class="line">    <a class="code" href="InitSystem_8h.html#ae332dfb8661c411f6d461d4b068ebb81">initSystem</a>();</div><div class="line">    <a class="code" href="SystemClock_8h.html#a81308abf4a2f57e7b17ce1c8e90d4a51">initSystemClock</a>();</div><div class="line">    <a class="code" href="Pwm_8h.html#af17c680cb05ffeb1312527c320870cbe">initPwmTimer2</a>();</div><div class="line">    <a class="code" href="Analog2Digital_8h.html#a1b09818d247959d12d61655cd0b7101f">initA2D</a>();</div><div class="line"></div><div class="line">    <a class="code" href="GpioPinMacros_8h.html#a8802f2fa85c2db869518a49ca6313d84">setGpioPinModeOutput</a>( pLed );</div><div class="line">    <a class="code" href="GpioPinMacros_8h.html#a8802f2fa85c2db869518a49ca6313d84">setGpioPinModeOutput</a>( pPwmLed );</div><div class="line">    <a class="code" href="GpioPinMacros_8h.html#a9e2956fa31869c862cc8ab76f8eec439">setGpioPinModeInput</a>( pPot );</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> ( 1 )</div><div class="line">    {</div><div class="line">        <span class="keywordtype">int</span> i = <a class="code" href="Analog2Digital_8h.html#a5043f69bc6307a1ada6ae3819ec11ff7">readGpioPinAnalog</a>( pPot ) / 4;</div><div class="line"></div><div class="line">        <a class="code" href="Pwm_8h.html#ad374c393f924ead532f5a0cd9e390d40">writeGpioPinPwm</a>( pPwmLed, i );</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ( i &gt; 127 )</div><div class="line">        {</div><div class="line">            <a class="code" href="GpioPinMacros_8h.html#afcd7e66a9c60b13bf749e18304a71ac6">setGpioPinHigh</a>( pLed );</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <a class="code" href="GpioPinMacros_8h.html#afb3e478c66e48ce826a6727737525bb9">setGpioPinLow</a>( pLed );</div><div class="line">        }</div><div class="line"></div><div class="line">        <a class="code" href="SystemClock_8h.html#a74d8aff40774c8a364845f0265776a24">delayMilliseconds</a>( 100 );</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="AdvancedModIntro"></a>
Advanced modules</h1>
<p>AVRTools also includes modules that provide access to more complex microcontroller capabilities and provide advanced services. These include modules for I2C communication (both master and slave mode), a module for SPI communications, a module for more advanced serial input and output (including conversion of various numerical types and strings), a module for temporarily surpressing selected interrupts, a module for driving an LCD display via I2C, a module for reporting memory utilization, a module for very precise delays, and a module for manipulating GPIO pins as actual variables. Information on these modules can be found in the <a class="el" href="AdvancedFeatures.html">Advanced Features</a> sections of the documentation.</p>
<h1>Documentation</h1>
<p>Detailed documentation is provided by this PDF document located in the repository, or <a href="http://igormiktor.github.io/AVRTools/">online in HTML form</a>.</p>
<h1><a class="anchor" id="QuestionsIntro"></a>
Questions</h1>
<p>If you have questions, please check out the <a class="el" href="faq.html#AvrFaq">FAQ</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 17 2017 15:36:24 for AVRTools by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
