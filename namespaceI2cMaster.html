<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AVRTools: I2cMaster Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AVRTools
   </div>
   <div id="projectbrief">A Library for the AVR ATmega328 and ATmega2560 Microcontrollers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">I2cMaster Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This namespace bundles the I2C-protocol-based interface to the TWI hardware. It provides logical cohesion for functions implement the Master portions of the I2C protocol and prevents namespace collisions.  
<a href="namespaceI2cMaster.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0968de4738f13ce811f6f7f3ee228292" id="r_a0968de4738f13ce811f6f7f3ee228292"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#a0968de4738f13ce811f6f7f3ee228292">I2cBusSpeed</a> { <a class="el" href="namespaceI2cMaster.html#a0968de4738f13ce811f6f7f3ee228292a67b829de73e215a8299a79b7a4deb074">kI2cBusSlow</a>
, <a class="el" href="namespaceI2cMaster.html#a0968de4738f13ce811f6f7f3ee228292aaf00edfa86af695617382919eebd0d47">kI2cBusFast</a>
 }</td></tr>
<tr class="memdesc:a0968de4738f13ce811f6f7f3ee228292"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum lists I2C bus speed configurations.  <a href="namespaceI2cMaster.html#a0968de4738f13ce811f6f7f3ee228292">More...</a><br /></td></tr>
<tr class="separator:a0968de4738f13ce811f6f7f3ee228292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc15f7c4cd5520421ee351e310db69b6" id="r_abc15f7c4cd5520421ee351e310db69b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#abc15f7c4cd5520421ee351e310db69b6">I2cStatusCodes</a> { <a class="el" href="namespaceI2cMaster.html#abc15f7c4cd5520421ee351e310db69b6a2f7f2a0a8c24783f82f72de24fc4fcab">kI2cCompletedOk</a> = 0x00
, <a class="el" href="namespaceI2cMaster.html#abc15f7c4cd5520421ee351e310db69b6a7e55ca88c09b4f95c652ada62d9e694d">kI2cError</a> = 0x01
, <a class="el" href="namespaceI2cMaster.html#abc15f7c4cd5520421ee351e310db69b6aaa41a52f117c1438af57e2c9397539d0">kI2cNotStarted</a> = 0x02
, <a class="el" href="namespaceI2cMaster.html#abc15f7c4cd5520421ee351e310db69b6adca2a28fd8bb4837b3c5fc2fb85c71cb">kI2cInProgress</a> = 0x04
 }</td></tr>
<tr class="memdesc:abc15f7c4cd5520421ee351e310db69b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum lists I2C status codes reported by the various transmit functions.  <a href="namespaceI2cMaster.html#abc15f7c4cd5520421ee351e310db69b6">More...</a><br /></td></tr>
<tr class="separator:abc15f7c4cd5520421ee351e310db69b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97252fd80d80c368f1fb47402bfeb3a4" id="r_a97252fd80d80c368f1fb47402bfeb3a4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#a97252fd80d80c368f1fb47402bfeb3a4">I2cSendErrorCodes</a> { <br />
&#160;&#160;<a class="el" href="namespaceI2cMaster.html#a97252fd80d80c368f1fb47402bfeb3a4ae7592fb54b2482a041002e358b8c0136">kI2cNoError</a> = 0
, <a class="el" href="namespaceI2cMaster.html#a97252fd80d80c368f1fb47402bfeb3a4ac211e69906718db3b7c982d092de9cc8">kI2cErrTxBufferFull</a> = 1
, <a class="el" href="namespaceI2cMaster.html#a97252fd80d80c368f1fb47402bfeb3a4a1dbe13c69ecd5f60a5804abffddabb7f">kI2cErrMsgTooLong</a> = 2
, <a class="el" href="namespaceI2cMaster.html#a97252fd80d80c368f1fb47402bfeb3a4aa8d986b05a52b6551979ce43eb29dae2">kI2cErrNullStatusPtr</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespaceI2cMaster.html#a97252fd80d80c368f1fb47402bfeb3a4a03f14e7f0733c0d8f5ad1e10fdd07059">kI2cErrWriteWithoutData</a> = 4
, <a class="el" href="namespaceI2cMaster.html#a97252fd80d80c368f1fb47402bfeb3a4aaf905ed9b3d8f31f9bacfb2e24cc6cda">kI2cErrReadWithoutStorage</a> = 5
<br />
 }</td></tr>
<tr class="memdesc:a97252fd80d80c368f1fb47402bfeb3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum lists I2C errors codes that may occur when you try to write a message.  <a href="namespaceI2cMaster.html#a97252fd80d80c368f1fb47402bfeb3a4">More...</a><br /></td></tr>
<tr class="separator:a97252fd80d80c368f1fb47402bfeb3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9839cfc29c6fa40e194426db97cab1b1" id="r_a9839cfc29c6fa40e194426db97cab1b1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#a9839cfc29c6fa40e194426db97cab1b1">I2cPullups</a> { <a class="el" href="namespaceI2cMaster.html#a9839cfc29c6fa40e194426db97cab1b1a5b00c294996a55832b7acebea2c40b64">kPullupsOff</a>
, <a class="el" href="namespaceI2cMaster.html#a9839cfc29c6fa40e194426db97cab1b1a0b29c25ea135b7bcc0929d6f65a118f5">kPullupsOn</a>
 }</td></tr>
<tr class="memdesc:a9839cfc29c6fa40e194426db97cab1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum lists the options for controlling the built-in pullups in the TWI hardware.  <a href="namespaceI2cMaster.html#a9839cfc29c6fa40e194426db97cab1b1">More...</a><br /></td></tr>
<tr class="separator:a9839cfc29c6fa40e194426db97cab1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac83dee34e238b9c36fc7357f73d09f9b" id="r_ac83dee34e238b9c36fc7357f73d09f9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#ac83dee34e238b9c36fc7357f73d09f9b">start</a> (uint8_t speed=<a class="el" href="namespaceI2cMaster.html#a0968de4738f13ce811f6f7f3ee228292aaf00edfa86af695617382919eebd0d47">kI2cBusFast</a>)</td></tr>
<tr class="memdesc:ac83dee34e238b9c36fc7357f73d09f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the TWI hardware for I2C communications in Master mode. You must call this function before conducting any I2C communications using the functions in this module.  <br /></td></tr>
<tr class="separator:ac83dee34e238b9c36fc7357f73d09f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f5ad4f6a0e8e29751d6621338b86b5" id="r_a65f5ad4f6a0e8e29751d6621338b86b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#a65f5ad4f6a0e8e29751d6621338b86b5">stop</a> ()</td></tr>
<tr class="memdesc:a65f5ad4f6a0e8e29751d6621338b86b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates the I2C communications using the TWI hardware, and disables the TWI interrupts.  <br /></td></tr>
<tr class="separator:a65f5ad4f6a0e8e29751d6621338b86b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b57e3382e8d694179251cb802e9c72" id="r_a89b57e3382e8d694179251cb802e9c72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#a89b57e3382e8d694179251cb802e9c72">pullups</a> (uint8_t set=<a class="el" href="namespaceI2cMaster.html#a9839cfc29c6fa40e194426db97cab1b1a0b29c25ea135b7bcc0929d6f65a118f5">kPullupsOn</a>)</td></tr>
<tr class="memdesc:a89b57e3382e8d694179251cb802e9c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state of the internal pullups that are part of the TWI hardware.  <br /></td></tr>
<tr class="separator:a89b57e3382e8d694179251cb802e9c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa97b1fcfac141edfd191206c84aafe6" id="r_aaa97b1fcfac141edfd191206c84aafe6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#aaa97b1fcfac141edfd191206c84aafe6">busy</a> ()</td></tr>
<tr class="memdesc:aaa97b1fcfac141edfd191206c84aafe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether the TWI hardware is busy communicating (either transmitting or receiving).  <br /></td></tr>
<tr class="separator:aaa97b1fcfac141edfd191206c84aafe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334b8d690dd3ef23b1e0ec48cbcaae00" id="r_a334b8d690dd3ef23b1e0ec48cbcaae00"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#a334b8d690dd3ef23b1e0ec48cbcaae00">writeAsync</a> (uint8_t address, uint8_t registerAddress, volatile uint8_t *status)</td></tr>
<tr class="memdesc:a334b8d690dd3ef23b1e0ec48cbcaae00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a single register address (a one-byte message) asynchronously. This function queues the message and returns immediately. Eventual status of the transmitted message can be monitored via the designated status variable (passed as a pointer to this function).  <br /></td></tr>
<tr class="separator:a334b8d690dd3ef23b1e0ec48cbcaae00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dbbe57f83912daa13b1ec527b8c8a3" id="r_a32dbbe57f83912daa13b1ec527b8c8a3"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#a32dbbe57f83912daa13b1ec527b8c8a3">writeAsync</a> (uint8_t address, uint8_t registerAddress, uint8_t data, volatile uint8_t *status)</td></tr>
<tr class="memdesc:a32dbbe57f83912daa13b1ec527b8c8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a single register address and corresponding single byte of data asynchronously. This function queues the message and returns immediately. Eventual status of the transmitted message can be monitored via the designated status variable (passed as a pointer to this function).  <br /></td></tr>
<tr class="separator:a32dbbe57f83912daa13b1ec527b8c8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7e0543938e4094eaa801ebfc8cd521" id="r_a8d7e0543938e4094eaa801ebfc8cd521"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#a8d7e0543938e4094eaa801ebfc8cd521">writeAsync</a> (uint8_t address, uint8_t registerAddress, const char *data, volatile uint8_t *status)</td></tr>
<tr class="memdesc:a8d7e0543938e4094eaa801ebfc8cd521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a single register address and corresponding null-terminated string of data asynchronously. This function queues the message and returns immediately. Eventual status of the transmitted message can be monitored via the designated status variable (passed as a pointer to this function).  <br /></td></tr>
<tr class="separator:a8d7e0543938e4094eaa801ebfc8cd521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d10ee2e81d48d8c88040cd980897843" id="r_a5d10ee2e81d48d8c88040cd980897843"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#a5d10ee2e81d48d8c88040cd980897843">writeAsync</a> (uint8_t address, uint8_t registerAddress, uint8_t *data, uint8_t numberBytes, volatile uint8_t *status)</td></tr>
<tr class="memdesc:a5d10ee2e81d48d8c88040cd980897843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a single register address and corresponding buffer of data asynchronously. This function queues the message and returns immediately. Eventual status of the transmitted message can be monitored via the designated status variable (passed as a pointer to this function).  <br /></td></tr>
<tr class="separator:a5d10ee2e81d48d8c88040cd980897843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817bd14c8540395eed0ebd4d5149b7b2" id="r_a817bd14c8540395eed0ebd4d5149b7b2"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#a817bd14c8540395eed0ebd4d5149b7b2">readAsync</a> (uint8_t address, uint8_t numberBytes, volatile uint8_t *destination, volatile uint8_t *bytesRead, volatile uint8_t *status)</td></tr>
<tr class="memdesc:a817bd14c8540395eed0ebd4d5149b7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request to read data from a device and receive that data asynchronously. This function queues the message and returns immediately. Eventual status of the transmitted message can be monitored via the designated status variable (passed as a pointer to this function). When the status variable reports kI2cCompletedOk, the requested data can be read from the receive buffer.  <br /></td></tr>
<tr class="separator:a817bd14c8540395eed0ebd4d5149b7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcad5ae556b935b5b38a264af8bb2ac2" id="r_abcad5ae556b935b5b38a264af8bb2ac2"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#abcad5ae556b935b5b38a264af8bb2ac2">readAsync</a> (uint8_t address, uint8_t registerAddress, uint8_t numberBytes, volatile uint8_t *destination, volatile uint8_t *bytesRead, volatile uint8_t *status)</td></tr>
<tr class="memdesc:abcad5ae556b935b5b38a264af8bb2ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request to read data from a specific register on a device and receive that data asynchronously. This function queues the message and returns immediately. Eventual status of the transmitted message can be monitored via the designated status variable (passed as a pointer to this function). When the status variable reports kI2cCompletedOk, the requested data can be read from the receive buffer.  <br /></td></tr>
<tr class="separator:abcad5ae556b935b5b38a264af8bb2ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99261b7c8fa73bc46436623038019081" id="r_a99261b7c8fa73bc46436623038019081"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#a99261b7c8fa73bc46436623038019081">writeSync</a> (uint8_t address, uint8_t registerAddress)</td></tr>
<tr class="memdesc:a99261b7c8fa73bc46436623038019081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a single register address (a one-byte message) synchronously. This function blocks until the communications exchange is complete or encounters an error. Error codes are returned (0 means no error).  <br /></td></tr>
<tr class="separator:a99261b7c8fa73bc46436623038019081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fb20a0439b7239e8a51693ae2e2779" id="r_aa1fb20a0439b7239e8a51693ae2e2779"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#aa1fb20a0439b7239e8a51693ae2e2779">writeSync</a> (uint8_t address, uint8_t registerAddress, uint8_t data)</td></tr>
<tr class="memdesc:aa1fb20a0439b7239e8a51693ae2e2779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a single register address and corresponding single byte of data synchronously. This function blocks until the communications exchange is complete or encounters an error. Error codes are returned (0 means no error).  <br /></td></tr>
<tr class="separator:aa1fb20a0439b7239e8a51693ae2e2779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fa629ea18f34803ed017f67ba3b9a2" id="r_aa2fa629ea18f34803ed017f67ba3b9a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#aa2fa629ea18f34803ed017f67ba3b9a2">writeSync</a> (uint8_t address, uint8_t registerAddress, const char *data)</td></tr>
<tr class="memdesc:aa2fa629ea18f34803ed017f67ba3b9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a single register address and corresponding null-terminated string of data synchronously. This function blocks until the communications exchange is complete or encounters an error. Error codes are returned (0 means no error).  <br /></td></tr>
<tr class="separator:aa2fa629ea18f34803ed017f67ba3b9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc2b7193dcc35fc9eaba3d130af5345" id="r_a6fc2b7193dcc35fc9eaba3d130af5345"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#a6fc2b7193dcc35fc9eaba3d130af5345">writeSync</a> (uint8_t address, uint8_t registerAddress, uint8_t *data, uint8_t numberBytes)</td></tr>
<tr class="memdesc:a6fc2b7193dcc35fc9eaba3d130af5345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a single register address and corresponding buffer of data synchronously. This function blocks until the communications exchange is complete or encounters an error. Error codes are returned (0 means no error).  <br /></td></tr>
<tr class="separator:a6fc2b7193dcc35fc9eaba3d130af5345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50eb37ed46981c09c5e0fb93832b685" id="r_ad50eb37ed46981c09c5e0fb93832b685"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#ad50eb37ed46981c09c5e0fb93832b685">readSync</a> (uint8_t address, uint8_t numberBytes, uint8_t *destination)</td></tr>
<tr class="memdesc:ad50eb37ed46981c09c5e0fb93832b685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request to read data from a device and receive that data synchronously. This function blocks until the communications exchange is complete or encounters an error. Error codes are returned (0 means no error).  <br /></td></tr>
<tr class="separator:ad50eb37ed46981c09c5e0fb93832b685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af884da3907c785422f6387c4108652cc" id="r_af884da3907c785422f6387c4108652cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceI2cMaster.html#af884da3907c785422f6387c4108652cc">readSync</a> (uint8_t address, uint8_t registerAddress, uint8_t numberBytes, uint8_t *destination)</td></tr>
<tr class="memdesc:af884da3907c785422f6387c4108652cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request to read data from a specific register on a device and receive that data synchronously. This function blocks until the communications exchange is complete or encounters an error. Error codes are returned (0 means no error).  <br /></td></tr>
<tr class="separator:af884da3907c785422f6387c4108652cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace bundles the I2C-protocol-based interface to the TWI hardware. It provides logical cohesion for functions implement the Master portions of the I2C protocol and prevents namespace collisions. </p>
<p>These interfaces are buffered for both input and output and operate using interrupts associated with the TWI hardware. This means the asynchronous transmit functions return immediately after queuing data in the output buffer for transmission and the transmission happens asynchronously, using dedicated TWI hardware. Similarly, data is received asynchronously and placed into the input buffer.</p>
<p>These functions are designed around the normal operating modes of the I2C protocol. From a Master device point of view, I2C communications consist of sending a designated device a message to do something, and then either:</p>
<ul>
<li>doing nothing because no further action required on the Master's part (e.g., telling the designated device to shutdown)</li>
<li>transmitting additional data needed by the designated device (e.g., telling the designated device to store some data)</li>
<li>receiving data from the designated device (e.g., telling the designated device to report the current temperature or to read back some data from its memory)</li>
</ul>
<p>For very simple devices, the receipt of the message itself can suffice to tell it to do something. More commonly, the instruction to the designated device consists of a single byte that passes a "register address" on the device. It is call a register address because it often corresponds directly to a memory register on the device. But it is best to think of it as an instruction code to the designated device (e.g., 0x01 = report the temperature; 0x02 = set the units to either F or C (depending on additional data sent by the Master); 0x03 = report the humidity; etc.)</p>
<p>The functions defined by this module conform directly to the above I2C paradigm. The functions come in both synchronous and asynchronous versions. The synchronous versions simply call the asynchronous versions and block internally until the asynchronous operations are complete.</p>
<p>Note also that even "read" operations always begin (from the Master's point of view) with a "send" to the designated device the Master wants to read data from. For this reason all operations (both read and write) utilize the transmit buffer. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0968de4738f13ce811f6f7f3ee228292" name="a0968de4738f13ce811f6f7f3ee228292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0968de4738f13ce811f6f7f3ee228292">&#9670;&#160;</a></span>I2cBusSpeed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceI2cMaster.html#a0968de4738f13ce811f6f7f3ee228292">I2cMaster::I2cBusSpeed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enum lists I2C bus speed configurations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0968de4738f13ce811f6f7f3ee228292a67b829de73e215a8299a79b7a4deb074" name="a0968de4738f13ce811f6f7f3ee228292a67b829de73e215a8299a79b7a4deb074"></a>kI2cBusSlow&#160;</td><td class="fielddoc"><p>I2C slow (standard) mode: 100 KHz. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0968de4738f13ce811f6f7f3ee228292aaf00edfa86af695617382919eebd0d47" name="a0968de4738f13ce811f6f7f3ee228292aaf00edfa86af695617382919eebd0d47"></a>kI2cBusFast&#160;</td><td class="fielddoc"><p>I2C fast mode: 400 KHz. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9839cfc29c6fa40e194426db97cab1b1" name="a9839cfc29c6fa40e194426db97cab1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9839cfc29c6fa40e194426db97cab1b1">&#9670;&#160;</a></span>I2cPullups</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceI2cMaster.html#a9839cfc29c6fa40e194426db97cab1b1">I2cMaster::I2cPullups</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enum lists the options for controlling the built-in pullups in the TWI hardware. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9839cfc29c6fa40e194426db97cab1b1a5b00c294996a55832b7acebea2c40b64" name="a9839cfc29c6fa40e194426db97cab1b1a5b00c294996a55832b7acebea2c40b64"></a>kPullupsOff&#160;</td><td class="fielddoc"><p>Disable the built-in TWI hardware pullups. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9839cfc29c6fa40e194426db97cab1b1a0b29c25ea135b7bcc0929d6f65a118f5" name="a9839cfc29c6fa40e194426db97cab1b1a0b29c25ea135b7bcc0929d6f65a118f5"></a>kPullupsOn&#160;</td><td class="fielddoc"><p>Enable the built-in TWI hardware pullups. </p>
</td></tr>
</table>

</div>
</div>
<a id="a97252fd80d80c368f1fb47402bfeb3a4" name="a97252fd80d80c368f1fb47402bfeb3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97252fd80d80c368f1fb47402bfeb3a4">&#9670;&#160;</a></span>I2cSendErrorCodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceI2cMaster.html#a97252fd80d80c368f1fb47402bfeb3a4">I2cMaster::I2cSendErrorCodes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enum lists I2C errors codes that may occur when you try to write a message. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a97252fd80d80c368f1fb47402bfeb3a4ae7592fb54b2482a041002e358b8c0136" name="a97252fd80d80c368f1fb47402bfeb3a4ae7592fb54b2482a041002e358b8c0136"></a>kI2cNoError&#160;</td><td class="fielddoc"><p>No error. </p>
</td></tr>
<tr><td class="fieldname"><a id="a97252fd80d80c368f1fb47402bfeb3a4ac211e69906718db3b7c982d092de9cc8" name="a97252fd80d80c368f1fb47402bfeb3a4ac211e69906718db3b7c982d092de9cc8"></a>kI2cErrTxBufferFull&#160;</td><td class="fielddoc"><p>The transmit buffer is full (try again later) </p>
</td></tr>
<tr><td class="fieldname"><a id="a97252fd80d80c368f1fb47402bfeb3a4a1dbe13c69ecd5f60a5804abffddabb7f" name="a97252fd80d80c368f1fb47402bfeb3a4a1dbe13c69ecd5f60a5804abffddabb7f"></a>kI2cErrMsgTooLong&#160;</td><td class="fielddoc"><p>The message is too long for the transmit buffer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a97252fd80d80c368f1fb47402bfeb3a4aa8d986b05a52b6551979ce43eb29dae2" name="a97252fd80d80c368f1fb47402bfeb3a4aa8d986b05a52b6551979ce43eb29dae2"></a>kI2cErrNullStatusPtr&#160;</td><td class="fielddoc"><p>The pointer to the status variable is null (need to provide a valid pointer) </p>
</td></tr>
<tr><td class="fieldname"><a id="a97252fd80d80c368f1fb47402bfeb3a4a03f14e7f0733c0d8f5ad1e10fdd07059" name="a97252fd80d80c368f1fb47402bfeb3a4a03f14e7f0733c0d8f5ad1e10fdd07059"></a>kI2cErrWriteWithoutData&#160;</td><td class="fielddoc"><p>No data provided to send. </p>
</td></tr>
<tr><td class="fieldname"><a id="a97252fd80d80c368f1fb47402bfeb3a4aaf905ed9b3d8f31f9bacfb2e24cc6cda" name="a97252fd80d80c368f1fb47402bfeb3a4aaf905ed9b3d8f31f9bacfb2e24cc6cda"></a>kI2cErrReadWithoutStorage&#160;</td><td class="fielddoc"><p>Performing a write+read, but no buffer provided to store the "read" data. </p>
</td></tr>
</table>

</div>
</div>
<a id="abc15f7c4cd5520421ee351e310db69b6" name="abc15f7c4cd5520421ee351e310db69b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc15f7c4cd5520421ee351e310db69b6">&#9670;&#160;</a></span>I2cStatusCodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceI2cMaster.html#abc15f7c4cd5520421ee351e310db69b6">I2cMaster::I2cStatusCodes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enum lists I2C status codes reported by the various transmit functions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abc15f7c4cd5520421ee351e310db69b6a2f7f2a0a8c24783f82f72de24fc4fcab" name="abc15f7c4cd5520421ee351e310db69b6a2f7f2a0a8c24783f82f72de24fc4fcab"></a>kI2cCompletedOk&#160;</td><td class="fielddoc"><p>I2C communications completed on this message with no error. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc15f7c4cd5520421ee351e310db69b6a7e55ca88c09b4f95c652ada62d9e694d" name="abc15f7c4cd5520421ee351e310db69b6a7e55ca88c09b4f95c652ada62d9e694d"></a>kI2cError&#160;</td><td class="fielddoc"><p>I2C communications had an error on this message. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc15f7c4cd5520421ee351e310db69b6aaa41a52f117c1438af57e2c9397539d0" name="abc15f7c4cd5520421ee351e310db69b6aaa41a52f117c1438af57e2c9397539d0"></a>kI2cNotStarted&#160;</td><td class="fielddoc"><p>I2C communications not started on this message. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc15f7c4cd5520421ee351e310db69b6adca2a28fd8bb4837b3c5fc2fb85c71cb" name="abc15f7c4cd5520421ee351e310db69b6adca2a28fd8bb4837b3c5fc2fb85c71cb"></a>kI2cInProgress&#160;</td><td class="fielddoc"><p>I2C communications on this message still in progress. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aaa97b1fcfac141edfd191206c84aafe6" name="aaa97b1fcfac141edfd191206c84aafe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa97b1fcfac141edfd191206c84aafe6">&#9670;&#160;</a></span>busy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2cMaster::busy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether the TWI hardware is busy communicating (either transmitting or receiving). </p>
<dl class="section return"><dt>Returns</dt><dd>true if the TWI hardware is busy communicating; false if the TWI hardware is idle. </dd></dl>

</div>
</div>
<a id="a89b57e3382e8d694179251cb802e9c72" name="a89b57e3382e8d694179251cb802e9c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b57e3382e8d694179251cb802e9c72">&#9670;&#160;</a></span>pullups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2cMaster::pullups </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>set</em> = <code><a class="el" href="namespaceI2cMaster.html#a9839cfc29c6fa40e194426db97cab1b1a0b29c25ea135b7bcc0929d6f65a118f5">kPullupsOn</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the state of the internal pullups that are part of the TWI hardware. </p>
<p><a class="el" href="namespaceI2cMaster.html#ac83dee34e238b9c36fc7357f73d09f9b" title="Configures the TWI hardware for I2C communications in Master mode. You must call this function before...">start()</a> automatically enables the internal pullups. You only need to call this function if you want to turn them off, or if you want to alter their state.</p>
<ul>
<li><code>set</code> the desired state of the built-in internal pullup. Defaults to enable (kPullupsOn). </li>
</ul>

</div>
</div>
<a id="a817bd14c8540395eed0ebd4d5149b7b2" name="a817bd14c8540395eed0ebd4d5149b7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817bd14c8540395eed0ebd4d5149b7b2">&#9670;&#160;</a></span>readAsync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2cMaster::readAsync </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numberBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>bytesRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request to read data from a device and receive that data asynchronously. This function queues the message and returns immediately. Eventual status of the transmitted message can be monitored via the designated status variable (passed as a pointer to this function). When the status variable reports kI2cCompletedOk, the requested data can be read from the receive buffer. </p>
<p>If the transmit buffer is full, this function will block until room is available in the buffer.</p>
<ul>
<li><code>address</code> the I2C address of the destination device you want to read from. </li>
<li><code>numberBytes</code> the number of bytes you expect to read. </li>
<li><code>destination</code> a pointer to a buffer in which the received data will be stored; the buffer should be at least <code>numberBytes</code> large. </li>
<li><code>bytesRead</code> a pointer to a byte-sized countered in which the TWI hardware will asynchronously keep track of how many bytes have been received. </li>
<li><code>status</code> a pointer to a byte-size location in which the commincations status of this message will be reported (volatile because the value will be updates asynchronously after the function returns by the TWI hardware) values correspond to I2cStatusCodes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>error codes corresponding to I2cSendErrorCodes (0 means no error) </dd></dl>

</div>
</div>
<a id="abcad5ae556b935b5b38a264af8bb2ac2" name="abcad5ae556b935b5b38a264af8bb2ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcad5ae556b935b5b38a264af8bb2ac2">&#9670;&#160;</a></span>readAsync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2cMaster::readAsync </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>registerAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numberBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>bytesRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request to read data from a specific register on a device and receive that data asynchronously. This function queues the message and returns immediately. Eventual status of the transmitted message can be monitored via the designated status variable (passed as a pointer to this function). When the status variable reports kI2cCompletedOk, the requested data can be read from the receive buffer. </p>
<p>If the transmit buffer is full, this function will block until room is available in the buffer.</p>
<ul>
<li><code>address</code> the I2C address of the destination device you want to read from. </li>
<li><code>registerAddress</code> in device-centric terms, the register address on the destination device; think of it as a one-byte instruction to the destination device telling it what you want to read (e.g., temperature or the starting address of a block of memory). </li>
<li><code>numberBytes</code> the number of bytes you expect to read. </li>
<li><code>destination</code> a pointer to a buffer in which the received data will be stored; the buffer should be at least <code>numberBytes</code> large. </li>
<li><code>bytesRead</code> a pointer to a byte-sized countered in which the TWI hardware will asynchronously keep track of how many bytes have been received. </li>
<li><code>status</code> a pointer to a byte-size location in which the commincations status of this message will be reported (volatile because the value will be updates asynchronously after the function returns by the TWI hardware); values correspond to I2cStatusCodes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>error codes corresponding to I2cSendErrorCodes (0 means no error) </dd></dl>

</div>
</div>
<a id="ad50eb37ed46981c09c5e0fb93832b685" name="ad50eb37ed46981c09c5e0fb93832b685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50eb37ed46981c09c5e0fb93832b685">&#9670;&#160;</a></span>readSync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int I2cMaster::readSync </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numberBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request to read data from a device and receive that data synchronously. This function blocks until the communications exchange is complete or encounters an error. Error codes are returned (0 means no error). </p>
<ul>
<li><code>address</code> the I2C address of the destination device you want to read from. </li>
<li><code>numberBytes</code> the number of bytes you expect to read. </li>
<li><code>destination</code> a pointer to a buffer in which the received data will be stored; the buffer should be at least <code>numberBytes</code> large.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>an error code which if positive corresponds to I2cSendErrorCodes, or if negative the absolute value corresponds to I2cStatusCodes (0 means no error). </dd></dl>

</div>
</div>
<a id="af884da3907c785422f6387c4108652cc" name="af884da3907c785422f6387c4108652cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af884da3907c785422f6387c4108652cc">&#9670;&#160;</a></span>readSync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int I2cMaster::readSync </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>registerAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numberBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request to read data from a specific register on a device and receive that data synchronously. This function blocks until the communications exchange is complete or encounters an error. Error codes are returned (0 means no error). </p>
<ul>
<li><code>address</code> the I2C address of the destination device you want to read from. </li>
<li><code>registerAddress</code> in device-centric terms, the register address on the destination device; think of it as a one-byte instruction to the destination device telling it what you want to read (e.g., temperature or the starting address of a block of memory). </li>
<li><code>numberBytes</code> the number of bytes you expect to read. </li>
<li><code>destination</code> a pointer to a buffer in which the received data will be stored; the buffer should be at least <code>numberBytes</code> large.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>an error code which if positive corresponds to I2cSendErrorCodes, or if negative the absolute value corresponds to I2cStatusCodes (0 means no error). </dd></dl>

</div>
</div>
<a id="ac83dee34e238b9c36fc7357f73d09f9b" name="ac83dee34e238b9c36fc7357f73d09f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83dee34e238b9c36fc7357f73d09f9b">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2cMaster::start </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>speed</em> = <code><a class="el" href="namespaceI2cMaster.html#a0968de4738f13ce811f6f7f3ee228292aaf00edfa86af695617382919eebd0d47">kI2cBusFast</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the TWI hardware for I2C communications in Master mode. You must call this function before conducting any I2C communications using the functions in this module. </p>
<p>This function enables the TWI related interrupts and enables the built-in hardware pullups.</p>
<ul>
<li><code>speed</code> the speed mode for the I2C protocol. The options are slow (100 KHz) or fast (400 KHz); the default is fast (kI2cBusFast). </li>
</ul>

</div>
</div>
<a id="a65f5ad4f6a0e8e29751d6621338b86b5" name="a65f5ad4f6a0e8e29751d6621338b86b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f5ad4f6a0e8e29751d6621338b86b5">&#9670;&#160;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2cMaster::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminates the I2C communications using the TWI hardware, and disables the TWI interrupts. </p>
<p>After calling this function, you need to call <a class="el" href="namespaceI2cMaster.html#ac83dee34e238b9c36fc7357f73d09f9b" title="Configures the TWI hardware for I2C communications in Master mode. You must call this function before...">start()</a> again if you want to resume I2C communications. </p>

</div>
</div>
<a id="a8d7e0543938e4094eaa801ebfc8cd521" name="a8d7e0543938e4094eaa801ebfc8cd521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7e0543938e4094eaa801ebfc8cd521">&#9670;&#160;</a></span>writeAsync() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2cMaster::writeAsync </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>registerAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a single register address and corresponding null-terminated string of data asynchronously. This function queues the message and returns immediately. Eventual status of the transmitted message can be monitored via the designated status variable (passed as a pointer to this function). </p>
<p>If the transmit buffer is full, this function will block until room is available in the buffer.</p>
<ul>
<li><code>address</code> the I2C address of the destination device for this message </li>
<li><code>registerAddress</code> in device-centric terms, the register address on the destination device; think of it as a one-byte instruction to the destination device telling it to do something (e.g., an address in a memory device). </li>
<li><code>data</code> a null-terminated string of data serving as a parameter to the register address (e.g., a string to store sequentially starting at the registerAddress). </li>
<li><code>status</code> a pointer to a byte-size location in which the commincations status of this message will be reported (volatile because the value will be updates asynchronously after the function returns by the TWI hardware); values correspond to I2cStatusCodes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>error codes corresponding to I2cSendErrorCodes (0 means no error) </dd></dl>

</div>
</div>
<a id="a5d10ee2e81d48d8c88040cd980897843" name="a5d10ee2e81d48d8c88040cd980897843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d10ee2e81d48d8c88040cd980897843">&#9670;&#160;</a></span>writeAsync() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2cMaster::writeAsync </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>registerAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numberBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a single register address and corresponding buffer of data asynchronously. This function queues the message and returns immediately. Eventual status of the transmitted message can be monitored via the designated status variable (passed as a pointer to this function). </p>
<p>If the transmit buffer is full, this function will block until room is available in the buffer.</p>
<ul>
<li><code>address</code> the I2C address of the destination device for this message </li>
<li><code>registerAddress</code> in device-centric terms, the register address on the destination device; think of it as a one-byte instruction to the destination device telling it to do something (e.g., an address in a memory device). </li>
<li><code>data</code> a buffer of data serving as a parameter to the register address (e.g., the data to store sequentially starting at the registerAddress). </li>
<li><code>numberBytes</code> the number of bytes from the buffer to transmit. </li>
<li><code>status</code> a pointer to a byte-size location in which the commincations status of this message will be reported (volatile because the value will be updates asynchronously after the function returns by the TWI hardware); values correspond to I2cStatusCodes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>error codes corresponding to I2cSendErrorCodes (0 means no error) </dd></dl>

</div>
</div>
<a id="a32dbbe57f83912daa13b1ec527b8c8a3" name="a32dbbe57f83912daa13b1ec527b8c8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32dbbe57f83912daa13b1ec527b8c8a3">&#9670;&#160;</a></span>writeAsync() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2cMaster::writeAsync </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>registerAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a single register address and corresponding single byte of data asynchronously. This function queues the message and returns immediately. Eventual status of the transmitted message can be monitored via the designated status variable (passed as a pointer to this function). </p>
<p>If the transmit buffer is full, this function will block until room is available in the buffer.</p>
<ul>
<li><code>address</code> the I2C address of the destination device for this message </li>
<li><code>registerAddress</code> in device-centric terms, the register address on the destination device; think of it as a one-byte instruction to the destination device telling it to do something (e.g., set the volume level). </li>
<li><code>data</code> a single byte of data serving as a parameter to the register address (e.g., the volume level to set). </li>
<li><code>status</code> a pointer to a byte-size location in which the commincations status of this message will be reported (volatile because the value will be updates asynchronously after the function returns by the TWI hardware); values correspond to I2cStatusCodes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>error codes corresponding to I2cSendErrorCodes (0 means no error) </dd></dl>

</div>
</div>
<a id="a334b8d690dd3ef23b1e0ec48cbcaae00" name="a334b8d690dd3ef23b1e0ec48cbcaae00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334b8d690dd3ef23b1e0ec48cbcaae00">&#9670;&#160;</a></span>writeAsync() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2cMaster::writeAsync </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>registerAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a single register address (a one-byte message) asynchronously. This function queues the message and returns immediately. Eventual status of the transmitted message can be monitored via the designated status variable (passed as a pointer to this function). </p>
<p>If the transmit buffer is full, this function will block until room is available in the buffer.</p>
<ul>
<li><code>address</code> the I2C address of the destination device for this message </li>
<li><code>registerAddress</code> in device-centric terms, the register address on the destination device; think of it as a one-byte instruction to the destination device telling it to do something (e.g., turn off or on). </li>
<li><code>status</code> a pointer to a byte-size location in which the commincations status of this message will be reported (volatile because the value will be updates asynchronously after the function returns by the TWI hardware); values correspond to I2cStatusCodes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>error codes corresponding to I2cSendErrorCodes (0 means no error) </dd></dl>

</div>
</div>
<a id="a99261b7c8fa73bc46436623038019081" name="a99261b7c8fa73bc46436623038019081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99261b7c8fa73bc46436623038019081">&#9670;&#160;</a></span>writeSync() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int I2cMaster::writeSync </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>registerAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a single register address (a one-byte message) synchronously. This function blocks until the communications exchange is complete or encounters an error. Error codes are returned (0 means no error). </p>
<ul>
<li><code>address</code> the I2C address of the destination device for this message. </li>
<li><code>registerAddress</code> in device-centric terms, the register address on the destination device; think of it as a one-byte instruction to the destination device telling it to do something (e.g., turn off or on).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>an error code which if positive corresponds to I2cSendErrorCodes, or if negative the absolute value corresponds to I2cStatusCodes (0 means no error). </dd></dl>

</div>
</div>
<a id="aa2fa629ea18f34803ed017f67ba3b9a2" name="aa2fa629ea18f34803ed017f67ba3b9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fa629ea18f34803ed017f67ba3b9a2">&#9670;&#160;</a></span>writeSync() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int I2cMaster::writeSync </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>registerAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a single register address and corresponding null-terminated string of data synchronously. This function blocks until the communications exchange is complete or encounters an error. Error codes are returned (0 means no error). </p>
<ul>
<li><code>address</code> the I2C address of the destination device for this message </li>
<li><code>registerAddress</code> in device-centric terms, the register address on the destination device; think of it as a one-byte instruction to the destination device telling it to do something (e.g., an address in a memory device). </li>
<li><code>data</code> a null-terminated string of data serving as a parameter to the register address (e.g., a string to store sequentially starting at the registerAddress).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>an error code which if positive corresponds to I2cSendErrorCodes, or if negative the absolute value corresponds to I2cStatusCodes (0 means no error). </dd></dl>

</div>
</div>
<a id="a6fc2b7193dcc35fc9eaba3d130af5345" name="a6fc2b7193dcc35fc9eaba3d130af5345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc2b7193dcc35fc9eaba3d130af5345">&#9670;&#160;</a></span>writeSync() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int I2cMaster::writeSync </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>registerAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numberBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a single register address and corresponding buffer of data synchronously. This function blocks until the communications exchange is complete or encounters an error. Error codes are returned (0 means no error). </p>
<ul>
<li><code>address</code> the I2C address of the destination device for this message </li>
<li><code>registerAddress</code> in device-centric terms, the register address on the destination device; think of it as a one-byte instruction to the destination device telling it to do something (e.g., an address in a memory device). </li>
<li><code>data</code> a buffer of data serving as a parameter to the register address (e.g., the data to store sequentially starting at the registerAddress). </li>
<li><code>numberBytes</code> the number of bytes from the buffer to transmit.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>an error code which if positive corresponds to I2cSendErrorCodes, or if negative the absolute value corresponds to I2cStatusCodes (0 means no error). </dd></dl>

</div>
</div>
<a id="aa1fb20a0439b7239e8a51693ae2e2779" name="aa1fb20a0439b7239e8a51693ae2e2779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1fb20a0439b7239e8a51693ae2e2779">&#9670;&#160;</a></span>writeSync() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int I2cMaster::writeSync </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>registerAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a single register address and corresponding single byte of data synchronously. This function blocks until the communications exchange is complete or encounters an error. Error codes are returned (0 means no error). </p>
<ul>
<li><code>address</code> the I2C address of the destination device for this message. </li>
<li><code>registerAddress</code> in device-centric terms, the register address on the destination device; think of it as a one-byte instruction to the destination device telling it to do something (e.g., set the volume level). </li>
<li><code>data</code> a single byte of data serving as a parameter to the register address (e.g., the volume level to set).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>an error code which if positive corresponds to I2cSendErrorCodes, or if negative the absolute value corresponds to I2cStatusCodes (0 means no error). </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
